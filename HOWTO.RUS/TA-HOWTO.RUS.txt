    
  Данный документ это - Traffic-Accounting-HOWTO
  ----------------------------------------------
  
  Оглавление
  
  1. Введение

    1.1 Что?
    1.2 Почему?
    1.3 Как?
    1.4 Где?

  2. Синтаксис файлов конфигурации

    2.1 Общий синтаксис
      2.1.1 Синтаксис переменных
      2.1.2 Синтаксис параметров
    2.2 Специальные символы
      2.2.1 Примеры использования

  3. Переменные главного файла конфигурации
    3.1 Предназначение
    3.2 Описание каждой переменной
    3.3 Примеры готовых конфигураций
    3.4 Ошибки конфигураций

  4. Переменные управления трафиком
    4.1 Предназначение
    4.2 Группы переменных
      4.2.1 Группа статистики
      4.2.2 Группа ведения лога
      4.2.3 Группа доступа
      4.2.4 Группа ведения отчётов
      4.2.5 Вспомогательная группа
      4.2.6 Группа лимитов
    4.3 Примеры готовых конфигураций
    4.4 Ошибки конфигураций

  5. Оптимизация конфигурации
    5.1 Оптимизация по скорости и размеру
    5.2 Зависимость скорости

  6. Учёт трафика
    6.1 Учёт по интерфейсам
    6.2 Учёт по IP адресам
    6.3 Учёт по протоколам
    6.4 Учёт по портам
    6.5 Учёт по каждому пакету
    
  7. Тесты работы Traffic Accounting
    7.1 Тесты версий
    7.2 Сравнение версий
    
  8. Дополнительные возможности TA
    8.1 Параметры командной строки
    8.2 Опустошение буфера
    
  9. Режим сервера
    9.1 Информация
    9.2 Необходимые настройки
    9.4 Создание акаунта
    9.5 Запуск в режиме сервера
    9.6 Запуск клиента
    
  10. Скины
    10.1 Для чего?
    10.2 Переменные скинов
    10.3 Как работает?
    10.4 Примеры

  11. Форматы
    11.1 Группа статистики
    11.2 Группа ведения логов
    11.3 Группа отчётов
    
  12. Утилиты
    12.1 Подробное описание
          
  13. Преимущества Traffic Accounting
  --------------------------------------------------------------------------------------


  1. Введение
  
    Данный документ предоставляет исчерпывающую информацию о том
    как можно настроить программу Traffic Accounting.
    В разделе 1.4 вы можете посмотреть как и где возможно взять
    программу Traffic Accounting, так же в разделе 1.4 указан адрес
    по которому можно получить последнюю версию данного документа.
    
  1.1 Что?
    
    Traffic Accounting это программа которая позволяет учитывать
    сетевой трафик по интерфейсам.
    Программа может вести отчёты, вести статистику, или общий подсчёт
    трафика, как по IP так и по интерфейсу в общем. Так же возможно
    учитывать трафик по портам и протоколам.
    Данная программа фильтрует трафик в пределах самой себя,
    любая функция не влияет на прохождение общего сетевого трафика.
    Всё это означает что данная программа может использоваться только
    как программа подсчёта трафика но не позволяет фильтровать пакеты
    или общий трафик на уровне ядра как к примеру ipchains, или iptables.
    
  1.2 Почему?
  
    На данный момент я не смог найти программу подходящую моим требованиям.
    Так как я имею отношение к системному администрированию мне необходимо
    было кроме общего учётра трафика учитывать его еще как-то.
    Все программы которые я находил не справлялись с задачами подобными моим.
    Поэтому я и решил открыть проект Traffic Accounting, мне кажется в этой
    программе собрано наибольшее колличество возможных операций над трафиком.
    На момент написания данной новой версии документации, колличество операций
    над трафиком составляет 86.
    Может быть я зря написал Traffic Accounting, потому что может быть
    уже есть программа лучше или такая же по возможностям, и я просто 
    плохо искал.
    В любом случае Traffic Accounting решает довольно большое колличество
    задач для подсчёта сетевого трафика.
    
  1.3 Как?
    
    На данный момент вам просто потребуется загрузить Traffic Accounting
    с сервера указанного в п. 1.4, и настроить его файлы конфигурации
    и просто запустить. Так же в состав входят некоторые рабочие конфигурации
    которые можно сразу же применить, как своеобразный faststart.
    
  1.4 Где?
    
    Официальная страница - Traffic Accounting <http://traflinux.sourceforge.net>
    
    Для сообщений об ошибках, свои мысли, или предложения можно отсылать
    по адресу yashin.sergey@gmail.com
    
  2. Синтаксис файлов конфигурации
    
  2.1 Общий синтаксис
  
    Общие правила для любых строк в файлах конфигурации.
    Каждая строка заканчивается символом возврата каретки.
    В одной строке может быть указано описание только для одной функции.
    Для каждой строки предусмотрены комментарии, это значит что если
    перед любой строкой стоит знак '#' то строка игнорируется.
    Перед знаком '#' стоять не может ничего.
  
  2.1.1 Синтаксис переменных
    
    Переменная должна начинаться с имени и заканчиваться символом '=' .
    Это главное правило для всех переменных.
    Например:
    
    variable=
    
  2.1.2 Синтаксис параметров
    
    Каждый параметр должен указываться после описания переменной,
    после символа '=' .
    Каждый параметр должен быть заключен в скобки '()'.
    Все параметры отделяются друг от друга символом '+'.
    Например:
    
    variable=(parameter1)+(parameter2)+(parameter3)+(parameter4)
    
    Если внутри какого-либо параметра должны находиться перечисления,
    то перечисления отделяются друг от друга символом ',' .
    Например:
    
    variable=(parameter1)+(parameter2)+(e1,e2,e3,e4,5)+(parameter4)
    
  2.2 Специальные символы
  
    Во всех файлах конфигурации, существуют специальные символы,
    к ним относятся: + ( ) = \
    так же изо всех строк удаляются пробелы.
    Как управлять специальными символами описано в п. 2.2.1
    
  2.2.1 Примеры использования
    
    Использование специальных символов может быть необходимо в следующем:
    если вы к примеру указываете имя файла для какой то из переменной,
    и имя файла должно содержать символ '+',
    например:
    
    /var/trafacct/eth1+eth4-traffic
  
    данная строка должна вызвать ошибку, но если перед символом '+' поставить
    символ '\' то ошибки не будет, так же с остальными спец символами.
    Любой символ следующий за символом '\' воспринимается как обычный символ.
    Например:
    
    /var/trafacct/eth1\+eth4-traffic
    /var/trafacct/eth1\\eth4-traffic
    /var/trafacct/eth1\ eth4-traffic
    /var/trafacct/eth1\(traffic\)
    
  3. Переменные главного файла конфигурации
  
  3.1 Предназначение
    
    Так как все описанные в п. 3 переменные принадлежат
    к главному файлу конфигурации то и предназначены они
    только для главного файла конфигурации.
    Главный файл конфигурации называется "ta.conf".
    По стандарту этот файл должен находиться в каталоге /etc/ ,
    но это можно изменить запустив Traffic Accounting со специальным
    параметром, параметры описаны в п. 8.
    
  3.2 Описание каждой переменной
    
    Перед тем как начать описание каждой из переменных,
    необходимо знать имена тех переменных которые _обязательно_
    должны находиться в главной файле конфигурации.
    К таким переменным относятся:
    dev, dir, mlog
    
    Описание каждой из переменных.
    
    1. dev
    
      В данной переменной перечисляются названия интерфейсов
      которые должны заносится в лог.
      Названия интерфейсов должны быть общими т.е.
      если нужно заносить в лог интерфейсы eth1, eth2, eth3
      то нужно записать первые буквы до перечисления т.е. "eth".
      Так же и для "ppp", "plip", и т.д.
      Пример:
      dev=(eth,lo,ppp)
      
    2. dir
    
      В данной переменной указывается название каталога
      для конфигурации управления логом для каждого из интерфейсов
      т.е. к примеру если указаны в переменной dev интерфейсы
      "eth", "ppp" то в этом каталоге должны находится файлы
      "eth-conf", "ppp-conf". Переменные для этих файлов конфигурации
      описаны ниже.
      Пример:
      dir=(/etc/ta/)
          
    3. mlog
    
      В данной переменной указывается имя файла в который будут
      заносится сообщения об ошибках в процессе работы программы.
      Пример:
      mlog=(/var/log/ta.log)

    4. server_port
    
      Данная переменная переключает Traffic Accounting
      в режим сервера.
      Параметр для данной переменной оди, и это порт
      который будет как изначальный для остальных портов,
      если такие потребуются.
      Пример:
      server_port=(5)
	    подробнее п. 9.
	    
    5. spec_ch
      В данной переменной указывается _один_ символ,
      этот символ будет использоваться для разделения
      полей в LOG`е. Описание формата логов находится
      в п. 11.
      Пример:
      spec_ch=(|)
                  
    6. skin_path
    
      Данная переменная сообщает для Traffic Accounting,
      где искать скины для функций ведения отчётов.
      Данную переменную необходимо использовать если используются
      функции ведения отчётов.
      Подробнее о скинах для функций ведения отчётов п. 10.
      Пример:
      skin_path=(/etc/ta/skins)
      
  3.3 Примеры готовых конфигураций
    
    В данном пункте представлены несколько примеров для
    главных файлов конфигурации.
    Примеры:
    
    1. Конфигурация с использованием функций ведения отчётов
    
     #--- CUT HERE ---
     
     dev=(lo)
     dir=(/etc/ta)
     mlog=(/var/log/ta.log)
     spec_ch=(|)
     skin_path=(/etc/ta/skins)
          
     #--- END CUT  ---
    
    2. Конфигурация без функций ведения отчётов

     #--- CUT HERE ---
     
     dev=(lo)
     dir=(/etc/ta)
     mlog=(/var/log/ta.log)
     spec_ch=(|)
          
     #--- END CUT  ---
    
    3. Конфигурация для работы Traffic Accounting в режиме server

     #--- CUT HERE ---
     
     dev=(lo)
     dir=(/etc/ta)
     mlog=(/var/log/ta.log)
     spec_ch=(|)
     server_port=(12)
          
     #--- END CUT  ---
     
  3.4 Ошибки конфигураций
  
    Всегда проверяйте существование директорий при занесении их
    в файлы конфигураций.
    Так же вы случайно можете забыть о том что в главном файле конфигурации
    забыли убрать переменную server_port. Если данную переменную не убрать
    и пытаться подсчитать локальный трафик то ничего не получится, логи
    будут чистыми, если конечно клиент на этой же машине не запущен.
    
  4. Переменные управления трафиком
  
  4.1 Предназначение
    
    Все переменные описанные в п. 4, относятся только
    к файлу конфигурации управления трафиком, и могут
    находится только в файле конфигурации управления трафиком.
    Путь к такому файлу складывается так:
    в главное конфигурационном файле из переменной dir
    берется имя каталога, далее для каждого интерфейса,
    указанного в переменной dev имя файла будет имя интерфейса+"-conf",
    к примеру dev=(lo,eth,ppp), из этого значит что файлы будут называться
    lo-conf,eth-conf,ppp-conf и лежать они должны в каталоге указанном
    в переменной dir, если dir=(/etc/ta) то для каждого путь будет
    /etc/ta/lo-conf
    /etc/ta/eth-conf
    /etc/ta/ppp-conf
    и именно для файлов типа lo-conf ниже в п. 4.2 описываются переменные.
    
  4.2 Группы переменных
    
    Все существующие переменные можно подразделить на отдельные
    группы, группы различаются результатом выполнения той или иной
    переменной.
    
  4.2.1 Группа статистики
  
    В данную группу входят такие переменные как:
    
    stat_global, stat_by_dev, stat_by_ip_global,
    stat_by_ip_dev, bin_stat_global, bin_stat_by_dev,
    bin_stat_by_ip_global, bin_stat_by_ip_dev,
    full_stat_global, full_stat_by_dev,
    full_stat_by_ip_global, full_stat_by_ip_dev
    bin_full_stat_global, bin_full_stat_by_dev
    bin_full_stat_by_ip_global, bin_full_stat_by_ip_dev
    
    Описание каждой из переменных.
    
    1. stat_global

	Переменная обязательно имеет 2 параметра.
	Параметры:
	    1)	Указывает на файл, в этот файл заносится
		каждый пакет, тип которого указан вторым
		параметром.
	    2)	Перечисление типов заносимых в лог пакетов.
	В лог данной переменной заносится каждый пакет
	в соответствии с типом указанным в п. 11.
	т.е. если указать несколько строк такой переменной
	то каждая будет вести себя по указанному типу, например
	если указать две строки:
	stat_global=(/var/trafacct/lo-stat-input)+(i)
	stat_global=(/var/trafacct/lo-stat-output)+(o)
	то в файл /var/trafacct/lo-stat-input будут заносится
	пакеты, которые имеют тип "i"(input), а во второй файл
	/var/trafacct/lo-stat-output будут заносится пакеты
	с типом "o".
	Но можно использовать и по одной строке:
	Пример:
	stat_global=(/var/trafacct/lo-stat)+(a)
	    или
	stat_global=(/var/trafacct/lo-stat)+(i,m)
    
    2. stat_by_dev
    
	Переменная имеет 4 параметра, но обязательными
	являются только 3.
	Параметры:
	    1)	Перечисление интерфейсов которые нужно заносить в лог.
	    2)	Файл в который заносится лог в соответствии с
		форматом приведенным в "DOCS/FMTCONF-RUS.text".
	    3)	Перечисление типов заносимых в лог пакетов.
	    4)	Имя для данной переменной, оно используется
		другой переменной пример этого приведен
		ниже(см. описание deny_ip_in_name).
	Функция предназначена для ведения лога, по определенным
	интерфейсам.
	Пример:
	stat_by_dev=(eth0,eth3,eth5)+(/var/trafacct/eth-dev-stat)+(o)+(name1)
	    или
	stat_by_dev=(eth0,eth3,eth5)+(/var/trafacct/eth-dev-stat)+(o)
    
    3. stat_by_ip_global

	Переменная имеет 4 параметра, но обязательными
	являются только 3.
	Параметры:
	    1)	Перечисление IP адресов для занесения их в лог-файл,
		который указан вторым параметром.
		IP адреса, перечисляются в следующем виде
		если нужно чтоб заносились в лог IP которые
		source, то нужно писать к примеру s212.45.67.98
		для destination в212.45.67.98, если нужно
		чтоб заносились в лог IP и оттуда и оттуда
		то можно указать a212.76.34.21, _но_тип_IP_должен
		_всегда_присутствовать.
		Можно указывать еще и диапазоны IP адресов
		к примеру s168.34.65.1-254, a200.21.45.23-87.
	    2)	Файл в который будет заносится статистика.
	    3)	Перечисление типов пакетов заносимых в статистику.
	    4)	Имя для данной переменной.
	Функция предназначенная для ведения лога статистики
	по определенным IP адресам.
	Пример:
	stat_by_ip_global=(s127.0.0.1-10,s127.0.0.34)+(/var/trafacct/lo-ip-stat)+(i,f)+(name2)
	
    4. stat_by_ip_dev
    
	Переменная имеет 5 параметров, но обязательными являются
	только 4.
	Параметры:
	    1)	Перечисление интерфейсов по которым будет
		вестись статистика.
	    2)	Перечисление IP адресов для интерфейсов, по которым
		будет вестись статистика.
	    3)	Фай статистики.
	    4)	Перечисление типов пакетов, для которых будет вестись
		статистика.
	    5) Имя переменной.
	Функция предназначена для ведения статистики для определенных
	интерфейсов, по IP адресам.
	Пример:
	stat_by_ip_dev=(eth3,eth1)+(s192.168.0.1-10,s192.168.0.34,d192.168.0.58)+(/var/trafacct/eth-dip-stat)+(f,o)+(test)

    5. bin_stat_global

	Данная функция аналогична к stat_global, разница только
	в формате статистики.
	Подробнее о формате п. 11.
    
    6. bin_stat_by_dev
    
	Данная функция аналогична к stat_by_dev, разница только
	в формате статистики.
	Подробнее о формате п. 11.
    
    7. bin_stat_by_ip_global
    
	Данная функция аналогична к stat_by_ip_global, разница только
	в формате статистики.
	Подробнее о формате п. 11.
	
    8. bin_stat_by_ip_dev
    
	Данная функция аналогична к stat_by_ip_dev, разница только
	в формате статистики.
	Подробнее о формате п. 11.
	
    9. full_stat_global
    
	Данная функция аналогична к stat_global, разница только
	в формате статистики.
	Подробнее о формате п. 11.
	
    10. full_stat_by_dev
    
	Данная функция аналогична к stat_by_dev, разница только
	в формате статистики.
	Подробнее о формате п. 11.
	
    11. full_stat_by_ip_global
    
	Данная функция аналогична к stat_by_ip_global, разница только
	в формате статистики.
	Подробнее о формате п. 11.
	
    12. full_stat_by_ip_dev

	Данная функция аналогична к stat_by_ip_dev, разница только
	в формате статистики.
	Подробнее о формате п. 11.
    
    13. bin_full_stat_global
    
	Данная функция аналогична к stat_global, разница только
	в формате статистики.
	Подробнее о формате п. 11.
	
    14. bin_full_stat_by_dev
    
	Данная функция аналогична к stat_by_dev, разница только
	в формате статистики.
	Подробнее о формате п. 11.
	
    15. bin_full_stat_by_ip_global
    
	Данная функция аналогична к stat_by_ip_global, разница только
	в формате статистики.
	Подробнее о формате п. 11.
    
    16. bin_full_stat_by_ip_dev
    
	Данная функция аналогична к stat_by_ip_dev, разница только
	в формате статистики.
	Подробнее о формате п. 11.
	
  4.2.2 Группа ведения лога
  
    В данную группу входят такие переменные как:
    
    log_file, log_by_ip, log_by_each_ip,
    log_by_port, log_by_each_port, log_by_proto,
    log_by_each_proto, log_by_port_ip, log_by_port_ip_each,
    log_by_eport_eip, log_by_each_ip_local, 
    log_by_ip_local, log_by_proto_ip, log_by_proto_ip_each,
    log_by_eproto_eip, full_log_by_each_ip.
    
    Описание каждой из переменных.
    
    1. log_file

	Переменная, обязательно, имеет 2 параметра.
	Параметры:
	    1) указывает на имя файла.
		В указанный файл, заносится количество
		байт, каждого пакета, для каждого типа пакета.
	    2) перечисление типов учитываемых пакетов.
		Типы могут быть:
		"i" - приходящий на интерфейс (input)
		"o" - исходящий с интерфейса (output)
		"f" - проходящий на другой интерфейс (forward)
		"b" - broadcast
		"m" - multicast
		"a" - Учитывать все (all)
		Эти типы могу содержать только _один_ символ,
		т.е. нельзя писать вместо "i", "input".
		Все эти типы могу быть перечислены одновременно,
		или же заменены на тип "a", так же
		типа "a" не может быть перечислен с другими типами,
		т.е. если он есть то он должен быть, только, один.
		Для формата лога п. 11.
	    3) Имя для данной переменной
	    
	Пример:
	log_file=(/var/trafacct/lo-log)+(i,o,f,b,m)
	    или
	log_file=(/var/trafacct/lo-log)+(a)
	    или
	log_file=(/var/trafacct/lo-log)+(i,f,m)
	    или
	log_file=(/var/trafacct/log_file)+(a)+(log_file_name)
	deny_dev_in_name=(log_file_name)+(eth5)
	
    2. log_by_ip

	Переменная имеет 4 параметра.
	Параметры:
	    1)	Перечисление IP адресов и/или диапазонов IP адресов.
	    2)	Строка c именем файла.
	    3)	Перечисление типов пакетов.
	    4)	Строка с именем.	    
	С помощью данной ф-ции можно уже суммировать трафик
	для отдельных ip адресов, т.е.
	эта функция аналогична, почти, функции "log_file"
	но теперь этот ЛОГ создается для отдельных и/или диапазонов IP адресов.
	Пример:
	log_by_ip=(s127.0.0.5,d127.0.0.10-56)+(/var/trafacct/lo-bip-log)+(i,o)+(name4)	
	
	Дальше в файле "/var/trafacct/lo-bip-log" мы можем увидеть ЛОГ
	подобный следующему:
	    +++
		lo|s127.0.0.5,d127.0.0.10-56|i:2268|b:0|m:0|f:0|o:2268
	    +++
	Подробнее в п. 11.
    
    3. log_by_each_ip

	Переменная имеет 4 параметра.
	Параметры:
	    1)	Перечисление IP адресов, или/и диапазонов.
	    2)	Строка с именем файла.
	    3)	Перечисление типов пакетов.
	    4)	Имя для данной переменной.
	Данная ф-ция практический клон к log_by_ip,
	но с одной лишь только разницей что это не ЛОГ
	по указанному диапазону а лог каждого IPадреса
	в указанном диапазоне, т.е. ЛОГ распространяется и
	создается для каждого IP попавшего в диапазон.
	Весь ЛОГ пишется в файл указанный параметром под номером 2.
	Записываются IPадреса совпадающие с диапазоном указанным
	в параметре номер 1, и проверяется совпадение на типы пакетов,
	в параметре номер 3.
	В данной переменной нужно использовать IPадреса и/или диапазоны
	___только___ с типом "a", например a127.0-12.45.20.
	Пример:
	log_by_each_ip=(a127.0.0.5,a127.0.0.10-56,a127.0.0.1/30)+(/var/trafacct/lo-IE-log)+(i,o)+(nameIE)

	Для данной строки ЛОГ будет выглядеть так:
	    +++
		lo|127.0.0.1|i:168|b:0|m:0|f:0|o:168
		lo|127.0.0.5|i:168|b:0|m:0|f:0|o:168
		lo|127.0.0.11|i:840|b:0|m:0|f:0|o:840
		lo|127.0.0.12|i:168|b:0|m:0|f:0|o:168
		lo|127.0.0.13|i:168|b:0|m:0|f:0|o:168
		lo|127.0.0.14|i:168|b:0|m:0|f:0|o:168
		lo|127.0.0.15|i:924|b:0|m:0|f:0|o:924		
	    +++
	Подробнее в п. 11.
    
    4. log_by_port
    
	Переменная имеет 5 параметров.
	Параметры:
	    1) Номер протокола, по портам которого будет вестись
	       лог. Стандартные номера это 17 для UDP и 6 для TCP.
	       Для того чтобы считать порты с UDP данный параметр
	       должен быть равен 17 .
	    2) В данном параметре указывается либо диапазон портов либо,
	       конкретный порт, но лучше указать диапазон так как для лога
	       по конкретному порту существует другая переменная.
	       Порты указываются как :
	       первый символ это a(all), s(source) или d(destination)
	       тип all:
		   он означает, что указанный порт может быть как
		   source так и destination.
	       тип source:
		   означает у пакета исходящий порт (порт откуда он прибыл).
	       тип destination:
		   означает у пакета порт назначения (порт на который прибыл).
	       после первого символа идёт номер порта, если диапазон то
	       указывается он так: a12-45
	       можно также в одном параметре совмещать: a12-45,d59,s34,d90-100
	    3) Файл в который будет записываться результат лога.
	    4) Перечисление типов пакетов.
	    5) Имя данной переменной, этот параметр необязателен если он
	       не требуется.
	       
	Данная переменная используется для ведения лога по диапазону портов,
	т.е. по нескольким портам сразу. Результаты этой переменной будут
	колличество байт переданных с/на диапазон портов.
	Формат лога для данной переменной описывается в п. 11.
	Пример:
	log_by_port=(17)+(a1-65535)+(/var/trafacct/log_by_port)+(b,f,m,i,o)+(lbp_name)
		
    5. log_by_each_port

	Переменная имеет 5 параметров.
	Параметры:
	    1) Номер протокола, по портам которого будет вестись
	       лог.
	    2) В данном параметре указывается либо диапазон портов либо,
	       конкретный порт, но лучше указать диапазон так как для лога
	       по конкретному порту существует другая переменная.
	    3) Файл в который будет записываться результат лога.
	    4) Перечисление типов пакетов.
	    5) Имя данной переменной, этот параметр необязателен если он
	       не требуется.
	       
	Данная переменная используется для ведения лога по каждому порту
	который входит в диапазон/перечисление указанным параметром 2.
	В результате лога, будет видно сколько ушло/пришло с/на каждый порт
	который входит в диапазон.
	Формат лога описывается в п. 11.
	Пример:
	log_by_each_port=(6)+(a1-65535)+(/var/trafacct/log_by_each_port)+(a)+(asdfg_name)
	
    6. log_by_proto
	
	Переменная имеет 4 параметра.
	Параметры:
	    1) В данном параметре указывается перечисление и/или диапазоны
	       протоколов. Например так: 12-10,6,17,1-5
	    2) Файл в который будет заносится результат работы переменной.
	    3) Перечисление типов пакетов.
	    4) Имя данной переменной, этот параметр необязателен если он
	       не требуется.
	       
	Данная переменная используется для ведения лога по диапазону
	протоколов, например если в первом параметре указать перечисления вида:
	1,6,17 то в результате можно увидеть сколько байт пришло/ушло
	с протоколами ICMP,TCP,UDP .
	Формат лога в п. 11.
	Пример:
	log_by_proto=(1,17)+(/var/trafacct/log_by_proto)+(a)+(lbprot_name)
	в результате мы увидим трафик для протоколов ICMP и UDP сколько
	пришло и ушло байт.
    
    7. log_by_each_proto

	Переменная имеет 4 параметра.
	Параметры:
	    1) В данном параметре указывается перечисление и/или диапазоны
	       протоколов.
	    2) Файл в который будет заносится результат работы переменной.
	    3) Перечисление типов пакетов.
	    4) Имя данной переменной, этот параметр необязателен если он
	       не требуется.
	       
	Результат работы данной переменной - лог в котором можно увидеть
	траффик для каждого из протоколов.
	Формат лога в п. 11.
	Пример:
	log_by_each_proto=(1,17)+(/var/trafacct/log_by_each_proto)+(i,o,b,f,m)+(log_by_each_proto)
	
    8. log_by_port_ip

	Переменная имеет 6 параметров.
	Параметры:    
	    1) Номер протокола, по портам которого будет вестись
	       лог.
	    2) Перечисление диапазонов IP адресов.	    
	    3) В данном параметре указывается либо диапазон портов либо,
	       конкретный порт, но лучше указать диапазон так как для лога
	       по конкретному порту существует другая переменная.
	    4) Файл в который будет записываться результат лога.
	    5) Перечисление типов пакетов.
	    6) Имя данной переменной, этот параметр необязателен если он
	       не требуется.
	
	Результатом работы данной переменной будет траффик по диапазону
	портов, для определенной группы IP адресов указываемых 
	в диапазоне (2-й параметр).
	Формат лога в п. 11.
	Пример:
	log_by_port_ip=(6)+(a127.0.0.20-40)+(a1-65535)+(/var/trafacct/log_by_port_ip)+(i,o,b,f,m)+(log_by_port_ip)
    
    9. log_by_port_ip_each
    
	Переменная имеет 6 параметров.
	Параметры:    
	    1) Номер протокола, по портам которого будет вестись
	       лог.
	    2) Перечисление диапазонов IP адресов.	    
	    3) В данном параметре указывается либо диапазон портов либо,
	       конкретный порт, но лучше указать диапазон так как для лога
	       по конкретному порту существует другая переменная.
	    4) Файл в который будет записываться результат лога.
	    5) Перечисление типов пакетов.
	    6) Имя данной переменной, этот параметр необязателен если он
	       не требуется.
	       
	Резуль татом работы данной переменной будет траффик по диапазону
	портов, указанных 3-м параметром, для каждого IP адреса входящего
	в диапазон/перечисление IP адресов(2-й параметр).
	Формат лога в п. 11.
	Пример:
	log_by_port_ip_each=(6)+(a127.0.0.1-10)+(a1-65535)+(/var/trafacct/log_by_port_ip_each)+(i,o,b,f,m)+(log_by_port_ip_each)
	
    10. log_by_eport_eip

	Переменная имеет 6 параметров.
	Параметры:    
	    1) Номер протокола, по портам которого будет вестись
	       лог.
	    2) Перечисление диапазонов IP адресов.	    
	    3) В данном параметре указывается либо диапазон портов либо,
	       конкретный порт, но лучше указать диапазон так как для лога
	       по конкретному порту существует другая переменная.
	    4) Файл в который будет записываться результат лога.
	    5) Перечисление типов пакетов.
	    6) Имя данной переменной, этот параметр необязателен если он
	       не требуется.
	       
	Результатом работы данной переменной будет лог в котором будет траффик
	по каждому IP адресу входящему в диапазон и по каждому порту(входящего
	в диапазон, указанный 3-м параметром) для каждого IP адреса.
	Формат лога в п. 11.
	Пример:
	log_by_eport_eip=(6)+(a127.0.0.1-10)+(a1-65535)+(/var/trafacct/log_by_eport_eip)+(i,o,b,f,m)+(log_by_eport_eip)
	
    11. log_by_each_ip_local

	Переменная имеет 4 параметра.
	Параметры:
	    1)	Перечисление IP адресов, или/и диапазонов.
	    2)	Строка с именем файла.
	    3)	Перечисление типов пакетов.
	    4)	Имя для данной переменной.
	
	Данная функция практически клон к log_by_each_ip, но исключение
	лишь то что этой функцией нужно пользоваться когда необходимо
	считать траффик для каждого IP адреса расположенного локально на
	той машине где запущен TA, или клиент. Данная переменной это старая
	реализация к log_by_each_ip. Данной переменной нельзя подсчитать
	траффик для IP адресов находящиеся к примеру в локальной сети, 
	но можно локальные. Поэтому если нужно подсчитать траффик для адресов в
	общей сети(локальной например) нужно использовать log_by_each_ip.
	Всё это доступно только с версии TA 1.1.0, переменная log_by_each_ip
	из прошлых функций не могла считать траффик для IP адресов во всей
	сети, а только локально находящихся на машине в которой запущен TA
	или клиент к TA.
	Формат лога в п. 11.
	Пример:
	log_by_each_ip_local=(a127.0.0.1-10)+(/var/trafacct/log_by_each_ip_local)+(i,o,b,f,m)+(log_by_each_ip_local)	
	
    12. log_by_ip_local

	Переменная имеет 4 параметра.
	Параметры:
	    1)	Перечисление IP адресов и/или диапазонов IP адресов.
	    2)	Строка c именем файла.
	    3)	Перечисление типов пакетов.
	    4)	Строка с именем.	    
	
	С помощью данной переменной можно считать траффик для диапазонов
	локальных IP адресов, тех адресов которые расположены на той машине
	на которой запущен TA или клиент к TA. Данная функция это старая 
	реализация log_by_ip. Если нужно считать траффик для диапазонов 
	в сети то нужно использовать log_by_ip. Такое доступно только
	с версии 1.1.0 . Прошлые версии не могу считать диапазоны IP адресов
	расположенные не локально т.е. не на той машине на которой запущены
	TA или клиент к TA.
	Формат лога в п. 11.
	Пример:
	log_by_ip_local=(a127.0.0.1-10)+(/var/trafacct/log_by_ip_local)+(a)+(log_by_ip_local)
	
    13. log_by_proto_ip	
	
	Переменная имеет 5 параметров.
	Параметры:
	    1) Перечисление диапазонов IP адресов.
	    2) В данном параметре указывается перечисление и/или диапазоны
	       протоколов. Например так: 12-10,6,17,1-5
	    3) Файл в который будет заносится результат работы переменной.
	    4) Перечисление типов пакетов.
	    5) Имя данной переменной, этот параметр необязателен если он
	       не требуется.
	
	Результат работы данной переменной будет траффик по диапазону
	протоколов для группы IP адресов перечисленных 1-м параметром.
	Формат лога в п. 11.
	Пример:
	log_by_proto_ip=(a127.0.0.1-10)+(1,17)+(/var/trafacct/log_by_proto_ip)+(i,o,b,f,m)+(log_by_proto_ip)

    14. log_by_proto_ip_each

	Переменная имеет 5 параметров.
	Параметры:
	    1) Перечисление диапазонов IP адресов.
	    2) В данном параметре указывается перечисление и/или диапазоны
	       протоколов. Например так: 12-10,6,17,1-5
	    3) Файл в который будет заносится результат работы переменной.
	    4) Перечисление типов пакетов.
	    5) Имя данной переменной, этот параметр необязателен если он
	       не требуется.
	
	Результатом работы данной функции будет лог в котором будет виден
	траффик по диапазону протоколов для каждого отдельного IP адреса
	который входит в перечисление IP адресов(1-й параметр).
	Формат лога описан в п. 11.
	Пример:
	log_by_proto_ip_each=(a127.0.0.1-10)+(1,17)+(/var/trafacct/log_by_proto_ip_each)+(i,o,b,f,m)+(log_by_proto_ip_each)
	
    15. log_by_eproto_eip
    
	Переменная имеет 5 параметров.
	Параметры:
	    1) Перечисление диапазонов IP адресов.
	    2) В данном параметре указывается перечисление и/или диапазоны
	       протоколов. Например так: 12-10,6,17,1-5
	    3) Файл в который будет заносится результат работы переменной.
	    4) Перечисление типов пакетов.
	    5) Имя данной переменной, этот параметр необязателен если он
	       не требуется.
	
	Результатом работы данной переменной будет траффик по каждому
	протоколу для каждого IP адреса, если оба из этих составляющих
	входят в указанные перечисления и диапазоны.
	Формат лога в п. 11.
	Пример:
	log_by_eproto_eip=(a127.0.0.1-10)+(1,17)+(/var/trafacct/log_by_eproto_eip)+(a)+(log_by_eproto_eip)

    16. full_log_by_each_ip

	Переменная имеет 4 параметра.
	Параметры:
	    1)	Перечисление IP адресов, или/и диапазонов.
	    2)	Строка с именем файла.
	    3)	Перечисление типов пакетов.
	    4)	Имя для данной переменной.
	Данная ф-ция практический клон к log_by_each_ip,
	но с одной лишь только разницей что данный ЛОГ для
	функции full_log_by_each_ip он показывает обмен трнафиком
	между адресами из диапазна и теми адресами с кем указанные IP
	адреса обменивались.
	Весь ЛОГ пишется в файл указанный параметром под номером 2.
	Записываются IPадреса совпадающие с диапазоном указанным
	в параметре номер 1, и проверяется совпадение на типы пакетов,
	в параметре номер 3.
	В данной переменной нужно использовать IPадреса и/или диапазоны
	___только___ с типом "a", например a127.0-12.45.20.
	Пример:
	full_log_by_each_ip=(a127.0.0.5,a127.0.0.10-56,a127.0.0.1/30)+(/var/trafacct/lo-IE-log)+(i,o)+(nameIE)

	Для данной строки ЛОГ будет выглядеть так:
	    +++
		lo|127.0.0.1->127.0.0.8|i:176|b:0|m:0|f:0|o:176
		lo|127.0.0.1->127.0.0.1|i:40|b:0|m:0|f:0|o:40
		lo|127.0.0.8->127.0.0.1|i:132|b:0|m:0|f:0|o:132
		lo|127.0.0.10->127.0.0.10|i:200|b:0|m:0|f:0|o:200
		lo|127.0.0.8->127.0.0.8|i:100|b:0|m:0|f:0|o:100
		lo|127.0.0.9->127.0.0.9|i:100|b:0|m:0|f:0|o:100
		lo|127.0.0.7->127.0.0.7|i:100|b:0|m:0|f:0|o:100
		lo|127.0.0.6->127.0.0.6|i:100|b:0|m:0|f:0|o:100
		lo|127.0.0.5->127.0.0.5|i:100|b:0|m:0|f:0|o:100
		lo|127.0.0.4->127.0.0.4|i:100|b:0|m:0|f:0|o:100	    
	    +++
	можно видеть что строка
	    lo|127.0.0.1->127.0.0.8|i:176|b:0|m:0|f:0|o:176
	показывает обмен между IP 127.0.0.1 и 127.0.0.8, 
	и тут видно что на 127.0.0.8 с адреса 127.0.0.1 пришло
	176 байт (".. i:176") и что ушло со 127.0.0.1 на 127.0.0.8
	176 байт (".. o:176").
	Подробнее в п. 11.

  4.2.3 Группа доступа
    
    В данную группу входят следующие переменные:
    
    deny_ip_global, deny_ip_in_type, deny_ip_in_name, deny_ip_in_dev,
    deny_dev, rs_by_proto_global, al_only_proto_global, rs_by_proto_idev,
    rs_by_proto_name, al_by_proto_idev, al_by_proto_name, 
    rs_by_port_global, al_by_port_global, al_by_port_itype, 
    rs_by_port_itype, rs_by_proto_itype, rs_by_port_idev, al_by_port_idev,
    al_by_proto_itype, rs_by_port_name, al_by_port_name,
    deny_ip_ptype_iname, alo_ip_global, alo_ip_in_type, alo_ip_in_name,
    alo_ip_in_dev, alo_dev, alo_ip_ptype_iname, deny_dev_in_name,
    alo_dev_in_name.
    
    Данные переменные определяют будет ли учтён пакет или нет,
    это можно определять как глобально и сразу же для всех функций,
    так и для отдельной взятой функции.
    
    Описание каждой из переменных.
    
    1. deny_ip_global

	Переменная имеет 1 параметр.
	Параметры:
	    1)	Перечисление IP адресов.
	Функция предназначена для игнорирования указанных IP адресов,
	глобально всеми остальными переменными статистики.
	Пример:
	deny_ip_global=(s127.0.0.89,a127.0.0.107)

    2. deny_ip_in_type

	Переменная имеет 2 параметра.
	Параметры:
	    1)	Перечисление типов пакетов.
	    2)	Перечисление IP адресов.
	Если, пришел пакет и его тип совпадает с перечисленным
	в этой переменной, и его IP тоже совпадает с перечисленным,
	тогда пакет отбрасывается глобально, и не учитывается ни одной
	из переменных.
	Пример:
	deny_ip_in_type=(i,o)+(a127.0.0.54,d218.45.19.1-90)
    
    3. deny_ip_in_dev
    
	Переменная имеет 2 параметра.
	Параметры:
	    1)	Перечисление типов интерфейсов.
	    2)	Перечисление IP адресов.
	Если, пакет пришел с интерфейса имя которого совпадает
	с перечисленным, и IP адрес пакета тоже совпадает с перечисленным
	то пакет никем не учитывается.
	Пример:
	deny_ip_in_dev=(ppp1,ppp5)+(s219.23.57.8,d137.51.28.3)
    
    4. deny_dev
    
	Переменная имеет 1 параметр.
	Параметры:
	    1)	Перечисление интерфейсов.
	Функция предназначена для отбрасывания любого пакета,
	пришедшего с любого перечисленного в данной переменной
	интерфейса.
	Пример:
	deny_dev=(ppp5,ppp10,ppp2)
	
    5. deny_ip_in_name
    
	Переменная имеет 2 параметра.
	Параметры:
	    1)	Строка с именем.
	    2)	Перечисление IP адресов.
	Функция предназначена для того чтобы отбрасывать
	пакеты. IP которых совпадает с перечисленными в данной переменной,
	отбрасывать с переменных по указанному имени.
	Пример:	
	stat_by_ip_global=(s127.0.0.1-10,s127.0.0.34)+(/var/trafacct/lo-ip-stat)+(a)+(name2)
	deny_ip_in_name=(name2)+(s127.0.0.3)
	
	В данном примере видно, что все пакеты указанные в stat_by_ip_global
	будут заносится в лог-файл, но так как deny_ip_in_name
	один IP s127.0.0.3 не будет занесен, так как он перечислен в 
	переменной запрещающей это, и указанное имя в stat_by_ip_global 
	совпадает с указанным в deny_ip_in_name

    6. rs_by_proto_global
    
	Переменная имеет 1 параметр.
	Параметры:
	    1) Перечисление протоколов, или диапазонов протоколов.
	Если протокол пакета совпадает с одним из перечисленных,
	или входит в диапазон, то игнорировать пакет 
	глобально(его не получит на обработку никто).
	Пример:
	rs_by_proto_global=(17,1,6)
	    Здесь мы запрещаем протоколы 6(TCP), 17(UDP) и 1(ICMP)
	    Все остальные будут учитываться.
	rs_by_proto_global=(4-10)
	    Здесь мы исключаем пакеты, с номерами с 4-го по 10-ый.
	rs_by_proto_global=(8-27,1,6)
	    Здесь исключаются с 8 по 27 + ICMP(1) и TCP(6).
	    
	IP=0	- Dummy protocol for TCP
	ICMP=1	- Internet Control Message Protocol
	IGMP=2	- Internet Group Management Protocol
	IPIP=4	- IPIP tunnels (older KA9Q tunnels use 94)
	TCP=6	- Transmission Control Protocol	
	EGP=8	- Exterior Gateway Protocol		
	PUP=12	- PUP protocol				
	UDP=17	- User Datagram Protocol		
	IDP=22	- XNS IDP protocol			
	RSVP=46	- RSVP protocol			
	GRE=47	- Cisco GRE tunnels (rfc 17011702)	
	IPV6=41	- IPv6-in-IPv4 tunnelling		
	PIM=103	- Protocol Independent Multicast	
	ESP=50  - Encapsulation Security Payload protocol 
	AH=51   - Authentication Header protocol       
	COMP=108 - Compression Header protocol 
	RAW=255	- Raw IP packets		

    7. al_only_proto_global
    
	Переменная имеет 1 параметр.
	Параметры:
	    1) Перечисление протоколов, или диапазонов протоколов.
	Эта функция полностью аналогична rs_by_proto_global
	за одним отличием, что она разрешает учитывать пакеты
	протоколы которых совпадают с перечисленными в параметре.
	Пример:
	al_only_proto_global=(6,1,17)
	    Здесь мы разрешаем учитывать пакеты, глобально,
	    только те протоколы которых TCP, ICMP или UDP.
	al_only_proto_global=(1-4,231)
	    Здесь разрешаем учёт пакетов только с протоколами
	    c 1-4 и 231.
	    
    8. rs_by_proto_idev
    
	Переменная имеет 2 параметра.
	Параметры:
	    1)	Перечисление интерфейсов.
	    2)	Перечисление протоколов, или диапазонов протоколов.
	Функция аналогична rs_by_proto_global только
	распространяется на отдельные интерфейсы.
	Пример:
	rs_by_proto_idev=(eth7,eth2)+(17,1)
	    Здесь если пакет с интерфейса eth7 или eth2 и у него
	    протоколы UDP(17) или ICMP(1) то он не учитывается.

    9. rs_by_proto_name
    
	Переменная имеет 2 параметра.
	Параметры:
	    1)	Строка с именем.
	    2)	Перечисление протоколов, или диапазонов протоколов.
	Функция аналогична rs_by_proto_global только
	действует на переменную с именем указанным первым параметром.
	Пример:
	stat_global=(/var/trafacct/global_stat.log)+(o,i)+(nameSG)
	rs_by_proto_name=(nameSG)+(1,17,20-45)
	    Здесь функция stat_global будет игнорировать пакеты
	    протоколы которых равны UDP, ICMP или их диапазон
	    от 20 до 45.

    10. al_by_proto_idev    
    
	Переменная имеет 2 параметра.
	Параметры:
	    1) Строка с перечислением интерфейсов.
	    2) Перечисление протоколов, или диапазонов протоколов.
	Функция аналогична rs_by_proto_idev, но с одним лишь отличием, что
	пропускаются все пакеты _только_ с протоколами указанными
	в перечислении, остальные же отвергаются.
	Пример:
	al_by_proto_idev=(eth3,eth1)+(6,17)
	    В данном примере на интерфейсах eth3 и eth1 мы разрешаем
	    учитывать только те пакеты протоколы которых равны 6 или 17
	    т.е. TCP и UDP.

    11. al_by_proto_name    
    
	Переменная имеет 2 параметра.
	Параметры:
	    1) Строка с именем.
	    2) Перечисление протоколов, или диапазонов протоколов.
	Функция аналогична rs_by_proto_name, но за одним лишь исключением,
	что разрешает только те пакеты протоколы которых равны перечисленным.
	Пример:
	stat_global=(/var/trafacct/global_stat.log)+(o,i)+(nameSG)
	al_by_proto_name=(nameSG)+(1,17,20-45)
	    Из данного примера можно видеть, что в файл "/var/trafacct/global_stat.log"
	    будут записываются пакеты протоколы которых равны
	    ICMP(1), UDP(17) или равные от 20 до 45.

    12. rs_by_port_global    
    
	Переменная имеет 2 параметра.
	Параметры:
	    1) Номер со значением протокола.
	    2) Перечисление портов.
	Функция глобально отбрасывает все пакеты указанного протокола
	и если они совпадают с перечисленными портами.
	Протокол(1-й параметр) может принимать значение исходя из 
	номера протокола TCP и UDP, для TCP должно быть равным 6 а для
	UDP равным 17.
	Порты перечисляются так:
	    первый символ это a(all), s(source) или d(destination)
	    тип all:
		он означает, что указанный порт может быть как
		source так и destination.
	    тип source:
		означает у пакета исходящий порт (порт откуда он прибыл).
	    тип destination:
		означает у пакета порт назначения (порт на который прибыл).
	Пример:
	rs_by_port_global=(6)+(d20-21,d110)
	    В данном примере отбрасываются пакеты протокола TCP которые
	    направляются на порты 20,21(FTP) и на порт 110(POP3).
	    Для UDP будет так:
	rs_by_port_global=(17)+(d5128)
	    Отбрасываются пакеты с протоколом UDP которые идут на 
	    порт 5128.

    13. al_by_port_global    
    
	Функция аналогична вышеуказанной rs_by_port_global
	но она не отбрасывает совпавшие пакеты а наоборот
	разрешает _только_ совпавшие пакеты.
	Пример:
	al_by_port_global=(6)+(d20-21,d110)
	    Будут учитываться только те пакеты протоколы которых
	    равны TCP и идут на порты FTP(20-21) и на POP3(110).

    14. al_by_port_itype    
    
	Переменная имеет 3 параметра.
	Параметры:
	    1) Перечисление типов пакетов.
	    2) Номер со значением протокола.
	    3) Перечисление портов.
	Данная функция разрешает учитывать пакеты только те 
	тип которых перечислен 1-ым параметром и порт которого
	совпадает тоже с одним из перечисленных, то эти пакеты
	учитываются, остальные нет.
	Пример:
	al_by_port_itype=(i,o)+(6)+(a20-21)
	    В данном примере учитываются _только_ пакеты
	    которые имеют тип input(i) или output(o)
	    и которые имеют протокол TCP и пришли/ушли с портов
	    20-21(FTP).
	    
    15. rs_by_port_itype    
    
	Функция полностью аналогична вышеописанной al_by_port_itype,
	за одним лишь исключением:
	функция rs_by_port_itype отвергает все пакеты в отличии от
	al_by_port_itype которая разрешает только.
	Пример:
	rs_by_port_itype=(o)+(17)+(d5128)
	    В данном примере отвергаются все UDP пакеты,
	    имеющие тип output (те которые исходят из интерфейса)
	    идущие на порт 5128.

    16. rs_by_proto_itype
    
	Переменная имеет 2 параметра.
	Параметры:
	    1) Перечисление типов пакетов.
	    2) Перечисление протоколов.
	Функция позволяет отвергать глобально все те пакеты,
	типы которых и протокол совпадают из перечисленных
	в параметрах.
	Пример:
	rs_by_proto_itype=(i)+(17)
	    Данный пример отвергает все пакеты которые 
	    имеют тип input(приходящие на интерфейс) и 
	    протокол UDP(17).

    17. al_by_proto_itype
    
	Функция аналогична rs_by_proto_itype, но только за 
	одним исключением, что al_by_proto_itype разрешает
	учитывать только те пакеты которые совпали с 
	параметрами указанными для переменной.
	Пример:
	al_by_proto_itype=(o)+(6)
	    В данном примере видно, что учитываются пакеты
	    тип которых output(исходящие с интерфейса) и
	    протокол которых - TCP(6).

    18. rs_by_port_idev    
    
	Переменная имеет 3 параметра.
	Параметры:
	    1) Перечисление интерфейсов.
	    2) Номер со значением протокола.
	    3) Перечисление портов.
	Функция позволяет отвергать с перечисленных интерфейсов
	все пакеты порты которых совпадают из указанных в параметре.
	Пример:
	rs_by_port_idev=(eth7,eth2)+(6)+(a20-12)
	    Из данного примера видно, что пакеты на интерфейсах
	    eth7,eth2 с протоколами TCP и с портами 20-21(FTP) в 
	    source или destination будут отвергаться.

    19. al_by_port_idev
    
	Функция аналогична rs_by_port_idev, но с одной разницей
	в том, что al_by_port_idev пропускает _только_ те пакеты 
	параметры которых совпадают из перечисленных для переменной,
	а остальные отбрасываются.
	Пример:
	al_by_port_idev=(ppp3,ppp0)+(6)+(a80)
	    На интерфейсах ppp0, ppp3 учитывать только пакеты
	    с протоколом TCP и с сервисом http(80).

    20. rs_by_port_name    
    
	Переменная имеет 3 параметра.
	Параметры:
	    1) Строка с именем.
	    2) Номер со значением протокола.
	    3) Перечисление портов.
	Функция позволяет отвергать все пакеты параметры которых
	совпали с перечисленными в переменной.
	Пример:
	stat_global=(/var/trafacct/loRStest)+(a)+(nameRStest)
	rs_by_port_name=(nameRStest)+(6)+(a20-21)
	    В данном примере в файл "/var/trafacct/loRStest"
	    будут добавляться все пакеты кроме тех
	    протокол которых равен 6(TCP) и
	    порты которых в любом месте равны 20-21(FTP).

    21. al_by_port_name    
    
	Функция аналогична rs_by_port_name за одним лишь исключением
	данная функция не отвергает, а разрешает и только те пакеты
	которые совпали с ее параметрами.
	Пример:
	stat_global=(/var/trafacct/loRStest)+(a)+(nameRStest)
	al_by_port_name=(nameRStest)+(17)+(d5128)
	    В данном примере файл "/var/trafacct/loRStest" будет
	    заполнятся только теми пакетами протокол которых равен
	    17(UDP) и порт назначения равный 5128.

    22. deny_ip_ptype_iname
    
	Данная переменная имеет 3 параметра.
	Параметры:
	    1) Строка с именем
	    2) Перечисление IP адресов
	    3) Перечисление типов пакетов
	
	Функция запрещает те пакеты тип которых совпадает с
	параметром 3 и IP адреса которого совпадают с параметром 2.
	Пример:
	stat_global=(/var/trafacct/loRStest)+(a)+(nameRStest)
	deny_ip_ptype_iname=(nameRStest)+(d127.0.0.8)+(i)
	    В данном примере если на input пришел пакет с
	    destination IP равном 127.0.0.8 то он отвергается для 
	    функции stat_global с именем nameRStest.
	    
    23. alo_ip_global
	
	Данная переменная имеет 1 параметр.
	Параметры:
	    1) Перечисление IP адресов.
	    
	Функция предназначена ограничивать трафик
	по IP адресам перечисленным как первый параметр.
	Пример:
	alo_ip_global=(a127.0.0.89-100)
	
	Данный пример ограничивает сетевой трафик по
	диапазону IP адресов a127.0.0.89-100, при этом
	любые другие пакеты с IP адресами не входящими в данный
	диапазон - отбрасываются.
	
    24. alo_ip_in_type
	
	Данная переменная имеет 2 параметра.
	Параметры:
	    1) Перечисление типов пакетов.
	    2) Перечисление IP адресов.
	    
	Функция предназначена для ограничения определенного
	типа пакетов по определенным адресам.
	Пример:
	alo_ip_in_type=(i,f)+(a192.78.11.20-10)
	
	Данный пример ограничивает пакеты с типом i(INPUT) и
	f(FORWARD) по диапазону IP адресов a192.78.11.20-10.
	После этого все пакеты типа которых i и f и IP адреса
	которых не совпадают с диапазоном - отбрасываются.
	
    25. alo_ip_in_name
    
	Данная переменная имеет 2 параметра.
	Параметры:
	    1) Строка с именем.
	    2) Перечисление диапазонов IP адресов.
	    
	Функция предназначена для ограничения переменной
	, имя которой совпадает с первым параметром, по
	IP адресам, все адреса после этого которые не подходят
	к диапазону, указанному во втором параметре, - отбрасываются
	для данной переменной.
	Пример:
	stat_global=(/var/trafacct/loRStest)+(a)+(nameRStest)
	alo_ip_in_name=(nameRStest)+(a200.200.1-10.1)
	
	После этого функция stat_global не будет учитывать те
	пакеты которые не подходят к диапазону a200.200.1-10.1 .
	
    26. alo_ip_in_dev
	
	Данная переменная имеет 2 параметра.
	Параметры:
	    1) Перечисление интерфейсов.
	    2) Перечисление диапазонов IP адресов.
	    
	Функция предназначена для ограничения определенных
	интерфейсов по определенным IP адресам.
	Пример:
	alo_ip_in_dev=(eth8,eth4)+(a192.168.0.30-50, a60.40.10.1-20)
	
	После этого для интерфейсов eth8, eth4 не будет учитываться пакеты
	совпадающие с диапазонами IP адресов a192.168.0.30-50, a60.40.10.1-20 .
	
    27. alo_dev
    
	Данная переменная имеет 1 параметр.
	Параметры:
	    1) Перечисление интерфейсов.
	    
	Функция ограничивает трафик по определенным интерфейсам.
	Пример:
	alo_dev=(eth0,eth5)
	
	После этого будут учитываться пакеты которые пришли/ушли с/на
	интерфейсы eth0,eth5, а остальные будут отбрасываться.
	
    28. alo_ip_ptype_iname
	
	Данная переменная имеет 3 параметра.
	Параметры:
	    1) Строка с именем.
	    2) Перечисление IP адресов.
	    3) Перечисление типов пакетов.
	    
	Функция предназначена для ограничения переменной, имя
	которой совпадает с первым параметром, по IP адресам
	и типам пакетов.
	Пример:
	stat_global=(/var/trafacct/loRStest)+(a)+(nameRStest)
	alo_ip_ptype_iname=(nameRStest)+(a192.168.0.1-5)+(i)
	
	После этого функция stat_global будет учитывать пакеты
	м типом i(INPUT) только такие, IP адреса которых будет
	совпадать с диапазоном a192.168.0.1-5, остальные пакеты
	с в типе i(INPUT) будут отбрасываться.
	
    29. deny_dev_in_name
    
	Данная переменная имеет 2 параметра.
	Параметры:
	    1) Строка с именем.
	    2) Перечисление имён интерфейсов.
	    
	Функиця предназначена для того чтобы отбрасывать
	все те пакеты интерфейс которых совпадает с перечисленным для
	данной переменной. Данная переменная не влияет на все фукнции
	глобально, а влияет только на ту имя которой указанно первым параметром
	к данной переменной, deny_dev_in_name.
	Пример:
	full_stat_global=(/var/trafacct/stat_global)+(a)+(stat_global)
	deny_dev_in_name=(stat_global)+(eth5, eth1)
	
	После этого пакеты с интерфейсов eth5, eth1 не будут записаны в
	статистику для функции full_stat_global.
	
    30. alo_dev_in_name

	Данная переменная имеет 2 параметра.
	Параметры:
	    1) Строка с именем.
	    2) Перечисление имён интерфейсов.
    
	Функиця предназначена для ограничения трафика, 
	ограничение по допустимым интерфейсам. Ограничение
	только для функции имя которой указанно первым параметром.
	Пример:
	full_stat_global=(/var/trafacct/stat_global)+(a)+(stat_global)
	alo_dev_in_name=(stat_global)+(eth5, eth1)
	
	После этого функция full_stat_global будет обрабатывать пакеты
	только с интерфейсов eth5, eth1.
		
  4.2.4 Группа ведения отчётов
    
    К данной группе относятся переменные, такие как:
    
    ls_by_iface, ls_by_each_ip,
    ls_by_port_ip_each, ls_by_eport_eip,
    ls_by_proto_ip_each, ls_by_eproto_eip,
    ls_full_by_each_ip, ls_by_each_ip_local,
    ls_by_ip, ls_by_proto_ip, ls_by_eproto_ip,
    ls_by_port_ip, ls_by_eport_ip.
    
    Описание каждой из переменных.
    
    1. ls_by_iface
	
	Данная переменная имеет 5 параметров.
	Параметры:
	    1) Файл в котором указан путь к скину
	    2) Файл в который будет заноситься отчёт
	    3) Перечисление типов пакетов
	    4) Время обновления (описание в п. 4.2.5)
	    5) Расширение для файла который указан 2-м параметром
    	    6) Формат отчёта текстовый (t) или использовать скин (s).
	    7) Имя для данной переменной.
	    
	Данная переменная используется для ведения отчётов о суммарном
	трафике по интерфейсам.
	Расширение для файла указывается например как ".%SS,%MM,%HH,%DD,%MO,%YR,%WW.html"
	В результате части с символом '%' заменятся на:
	SS - секунды (0-60)
	MM - минуты  (0-60)
	HH - часы    (0-24)
	DD - день месяца (1-{28,30,31})
	MO - месяц, его номер (1-12)
	YR - год, формат 4-х значный (2002)
	WW - номер дня в неделе:
		    1) понедельник
		    2) вторник
		     ...
		    6) суббота
		    7) воскресение
		    
	Формат лога описывается в п 10.
	Пример:
	ls_by_iface=(skin_b.cf)+(/var/trafacct/ls_by_iface)+(i,o,b,f,m)+(*/10|*|*|*|*|*|*)+(.%SS,%MM,%HH,%DD,%MO,%YR,%WW.html)+(t)+(ls-iface)
	
    2. ls_by_each_ip
	
	Данная переменная имеет 6 параметров.
	Параметры:
	    1) Файл в котором указан путь к скину
	    2) Перечисление диапазонов IP адресов
	    3) Файл в который будет заноситься отчёт
	    4) Перечисление типов пакетов
	    5) Время обновления (описание в п. 4.2.5)
	    6) Расширение для файла который указан 2-м параметром
    	    7) Формат отчёта текстовый (t) или использовать скин (s).
	    8) Имя для данной переменной.
	
	Данная переменная используется для ведения отчётов о суммарном
	количестве трафика для каждого из IP адресов входящий в 
	диапазон, указанный 2-м параметром.
	
	Формат описан в п. 10.
	Пример:
	ls_by_each_ip=(skin_a.cf)+(a127.0.0.1-9,a127.0.0.10-56)+(/var/trafacct/ls_by_each_ip)+(i,o,b,f,m)+(*/10|*|*|*|*|*|*)+(.%SS,%MM,%HH,%DD,%MO,%YR,%WW.html)+(t)+(ls_by_each_ip_name)

    3. ls_by_port_ip_each
    
	Данная переменная имеет 8 параметров.
	  Параметры:
	    1) Файл в котором указан путь к скину
	    2) Номер протокола 17(UDP), 6(TCP)
	    3) Перечисление диапазонов IP адресов
	    4) Перечисление диапазонов портов
	    5) Файл в который будет заноситься отчёт
	    6) Перечисление типов пакетов
	    7) Время обновления (описание в п. 4.2.5)
	    8) Расширение для файла который указан 2-м параметром	    
    	    9) Формат отчёта текстовый (t) или использовать скин (s).
	    10) Имя для данной переменной.
    
	Функция предназначена для ведения отчётов по диапазонам портов
	каждого IP адреса, который входит указанный 3-м параметром диапазон.
	
	Формат описан в п. 10.
	Пример:
	ls_by_port_ip_each=(skin_b.cf)+(6)+(a127.0.0.1-10)+(a1-60)+(/var/trafacct/ls_by_port_ip_each)+(i,o,b,f,m)+(*/10|*|*|*|*|*|*)+(.%SS,%MM,%HH,%DD,%MO,%YR,%WW.html)+(t)+(ls_by_port_ip_each_name)
	
    4. ls_by_eport_eip
	
	Данная переменная имеет 8 параметров.
	  Параметры:
	    1) Файл в котором указан путь к скину
	    2) Номер протокола 17(UDP), 6(TCP)
	    3) Перечисление диапазонов IP адресов
	    4) Перечисление диапазонов портов
	    5) Файл в который будет заноситься отчёт
	    6) Перечисление типов пакетов
	    7) Время обновления (описание в п. 4.2.5)
	    8) Расширение для файла который указан 2-м параметром	    
    	    9) Формат отчёта текстовый (t) или использовать скин (s).
	    10) Имя для данной переменной.
    
	Данная функция предназначена для ведения отчётов по
	каждому порту для каждого IP адреса, которые входят
	в указанные диапазоны.
	
	Формат описан в п. 10.
	Пример:
	ls_by_eport_eip=(skin_b.cf)+(6)+(a127.0.0.1-10)+(a1-60)+(/var/trafacct/ls_by_eport_eip)+(i,o,b,f,m)+(*/5|*|*|*|*|*|*)+(.%SS,%MM,%HH,%DD,%MO,%YR,%WW.html)+(t)+(ls_by_eport_eip_name)
	
    5. ls_by_proto_ip_each
    
	Данная переменная имеет 8 параметров.
	  Параметры:
	    1) Файл в котором указан путь к скину
	    2) Перечисление диапазонов IP адресов
	    3) Перечисление диапазонов протоколов
	    4) Файл в который будет заноситься отчёт
	    5) Перечисление типов пакетов
	    6) Время обновления (описание в п. 4.2.5)
	    7) Расширение для файла который указан 2-м параметром	    	
    	    8) Формат отчёта текстовый (t) или использовать скин (s).
	    9) Имя для данной переменной.
	
	
	Функция предназначена для ведения отчётов по диапазонам
	протоколов для каждого IP адреса который входит в диапазон,
	указанный 2-м параметром.
	
	Формат описан в п. 10.
	Пример:
	ls_by_proto_ip_each=(skin_b.cf)+(a127.0.0.1-10)+(1-60)+(/var/trafacct/ls_by_proto_ip_each)+(i,o,b,f,m)+(*/5|*|*|*|*|*|*)+(.%SS,%MM,%HH,%DD,%MO,%YR,%WW.html)+(t)+(ls_by_proto_ip_each_name)

    6. ls_by_eproto_eip
        
	Данная переменная имеет 8 параметров.
	  Параметры:
	    1) Файл в котором указан путь к скину
	    2) Перечисление диапазонов IP адресов
	    3) Перечисление диапазонов протоколов
	    4) Файл в который будет заноситься отчёт
	    5) Перечисление типов пакетов
	    6) Время обновления (описание в п. 4.2.5)
	    7) Расширение для файла который указан 2-м параметром	
    	    8) Формат отчёта текстовый (t) или использовать скин (s).
	    9) Имя для данной переменной.
	
	Функция предназначена для ведения отчётов по каждому
	протоколу каждого IP адреса, которые входят в указанные
	диапазоны.
	
	Формат описан в п. 10.
	Пример:
	ls_by_eproto_eip=(skin_b.cf)+(a127.0.0.1-10)+(1-60)+(/var/trafacct/ls_by_eproto_eip)+(i,o,b,f,m)+(*/5|*|*|*|*|*|*)+(.%SS,%MM,%HH,%DD,%MO,%YR,%WW.html)+(t)+(ls_by_eproto_eip)
	
    7. ls_full_by_each_ip

	Данная переменная имеет 8 параметров.
	  Параметры:
	    1) Файл в котором указан путь к скину
	    2) Перечисление диапазонов IP адресов
	    3) Файл в который будет заноситься отчёт
	    4) Перечисление типов пакетов
	    5) Время обновления (описание в п. 4.2.5)
	    6) Расширение для файла который указан 2-м параметром
    	    7) Формат отчёта текстовый (t) или использовать скин (s).
	    8) Имя для данной переменной.

	Данная переменная используется для ведения отчётов о суммарном
	количестве трафика для каждого из IP адресов входящий в 
	диапазон, указанный 2-м параметром.
	
	Формат описан в п. 10.
	Пример:
	ls_full_by_each_ip=(skin_b.cf)+(a127.0.0.1-10)+(/var/trafacct/testing/ls_full_by_each_ip)+(a)+(*/5|*|*|*|*|*|*)+(_%UT)+(t)+(ls_full_by_each_ip_name)
	
    8. ls_by_each_ip_local
	
	Данная переменная имеет 6 параметров.
	Параметры:
	    1) Файл в котором указан путь к скину
	    2) Перечисление диапазонов IP адресов
	    3) Файл в который будет заноситься отчёт
	    4) Перечисление типов пакетов
	    5) Время обновления (описание в п. 4.2.5)
	    6) Расширение для файла который указан 2-м параметром
    	    7) Формат отчёта текстовый (t) или использовать скин (s).
	    8) Имя для данной переменной.
	
	Данная переменная используется для ведения отчётов о суммарном
	количестве трафика для каждого из IP адресов входящий в 
	диапазон, указанный 2-м параметром.
	
	Формат описан в п. 10.
	Пример:
	ls_by_each_ip_local=(skin_b.cf)+(a127.0.0.1-10)+(/var/trafacct/testing/ls_by_each_ip_local)+(a)+(*/5|*|*|*|*|*|*)+(_%UT)+(t)+(ls_by_each_ip_local)
		
    9. ls_by_ip

	Данная переменная имеет 8 параметров.
	  Параметры:
	    1) Файл в котором указан путь к скину
	    2) Перечисление диапазонов IP адресов
	    3) Файл в который будет заноситься отчёт
	    4) Перечисление типов пакетов
	    5) Время обновления (описание в п. 4.2.5)
	    6) Расширение для файла который указан 2-м параметром
    	    7) Формат отчёта текстовый (t) или использовать скин (s).
	    8) Имя для данной переменной.
    
	Данная функция полная копия функции log_by_ip,
	но только ls_by_ip для вывода данных использует
	отчёты.

	Формат описан в п. 10.
	Пример:
	ls_by_ip=(skin_a.cf)+(a127.0.0.1-10,a127.0.0.15)+(/var/trafacct/lo/time/group2.ls-lip)+(a)+(*|*|_|*|*|*|*)+(_%UT)+(t)+(ls-lip)    
	
    10. ls_by_proto_ip

	Данная переменная имеет 8 параметров.
	  Параметры:
	    1) Файл в котором указан путь к скину
	    2) Перечисление диапазонов IP адресов
	    3) Перечисление диапазонов протоколов
	    4) Файл в который будет заноситься отчёт
	    5) Перечисление типов пакетов
	    6) Время обновления (описание в п. 4.2.5)
	    7) Расширение для файла который указан 2-м параметром	
    	    8) Формат отчёта текстовый (t) или использовать скин (s).
	    9) Имя для данной переменной.
	

	Данная функция полная копия функции log_by_proto_ip,
	но только ls_by_proto_ip для вывода данных использует
	отчёты.

	Формат описан в п. 10.
	Пример:
	ls_by_proto_ip=(skin_a.cf)+(a127.0.0.1-10,a127.0.0.15)+(0-255)+(/var/trafacct/lo/time/group2.ls-gpri)+(a)+(*|*|_|*|*|*|*)+(_%UT)+(t)+(ls-gpri)

    11. ls_by_eproto_ip

	Данная переменная имеет 8 параметров.
	  Параметры:
	    1) Файл в котором указан путь к скину
	    2) Перечисление диапазонов IP адресов
	    3) Перечисление диапазонов протоколов
	    4) Файл в который будет заноситься отчёт
	    5) Перечисление типов пакетов
	    6) Время обновления (описание в п. 4.2.5)
	    7) Расширение для файла который указан 2-м параметром	
    	    8) Формат отчёта текстовый (t) или использовать скин (s).
	    9) Имя для данной переменной.
	
	Функция предназначена для ведения отчётов по каждому
	протоколу для указанного диапазона IP адресов.

	Формат описан в п. 10.
	Пример:
	ls_by_eproto_ip=(skin_a.cf)+(a127.0.0.1-10,a127.0.0.15)+(0-255)+(/var/trafacct/lo/time/group2.ls-gepri)+(a)+(*|*|_|*|*|*|*)+(_%UT)+(t)+(ls-gepri)
	
    12. ls_by_port_ip

	Данная переменная имеет 8 параметров.
	  Параметры:
	    1) Файл в котором указан путь к скину
	    2) Номер протокола 17(UDP), 6(TCP)
	    3) Перечисление диапазонов IP адресов
	    4) Перечисление диапазонов портов
	    5) Файл в который будет заноситься отчёт
	    6) Перечисление типов пакетов
	    7) Время обновления (описание в п. 4.2.5)
	    8) Расширение для файла который указан 2-м параметром	    
    	    9) Формат отчёта текстовый (t) или использовать скин (s).
	    10) Имя для данной переменной.

	Данная функция полная копия функции log_by_port_ip,
	но только ls_by_port_ip для вывода данных использует
	отчёты.

	Формат описан в п. 10.
	Пример:
	ls_by_port_ip=(skin_a.cf)+(6)+(a127.0.0.1-10,a127.0.0.15)+(a1-65535)+(/var/trafacct/lo/time/group2.ls-tcp-gpi)+(a)+(*|*|_|*|*|*|*)+(_%UT)+(t)+(ls-tcp-gpi)
        
    13. ls_by_eport_ip

	Данная переменная имеет 8 параметров.
	  Параметры:
	    1) Файл в котором указан путь к скину
	    2) Номер протокола 17(UDP), 6(TCP)
	    3) Перечисление диапазонов IP адресов
	    4) Перечисление диапазонов портов
	    5) Файл в который будет заноситься отчёт
	    6) Перечисление типов пакетов
	    7) Время обновления (описание в п. 4.2.5)
	    8) Расширение для файла который указан 2-м параметром	    
    	    9) Формат отчёта текстовый (t) или использовать скин (s).
	    10) Имя для данной переменной.

	Данная функция предназначена для ведения отчётов по
	каждому порту для указанног диапазона IP адресов.

	Формат описан в п. 10.
	Пример:
	ls_by_eport_ip=(skin_a.cf)+(6)+(a127.0.0.1-10,a127.0.0.15)+(a1-65535)+(/var/trafacct/lo/time/group2.ls-tcp-gepi)+(a)+(*|*|_|*|*|*|*)+(_%UT)+(t)+(ls-tcp-gepi)
    
  4.2.5 Вспомогательная группа	
    
    К данной группе относятся переменные, такие как:
    
    time_stamp, stat_time_on, save_on_time,
    priority, ip_entry_list.
    
    Описание каждой из переменных.
    
    1. time_stamp
	Данная переменная имеет 1 параметр.
	Параметры:
	    1) yes или no
	
	Данная переменная влияет на результаты функций
	из группы ведения статистики, если данная переменная
	установлена в yes то к каждой записи у функций статистики
	добавляется time stamp в unix time формате, это время пакета,
	т.е. то время когда он "появился".
	Подробнее показано в п. 11.
	Пример:
	time_stamp=(yes)
	
    2. stat_time_on

	Переменная имеет 4 параметра.
	Параметры:
	    1)	Строка с именем.
	    2)	Строка с именем файла.
	    3)	Время обновления в ниже приведенном формате.
	    4)	Расширение файла в формате описанном ниже.
	Данная функция имеет параметр в котором можно
	указать имя какой либо из функций(stat) и дальше
	stat_time_on изменит параметры ф-ции так, что
	она будет записывать свою статистику в разные файлы
	в соответствии с промежутками времени, которые указываются
	так же в параметре ф-ции stat_time_on.
	Данная функция работает _только_ с какой-либо из переменных
	статистики (stat_).
	Пример:
	
	Время задается как и в crontab только добавлены еще и секунды.
	Тем кто не хочет использовать секунды или его это пугает то
	просто этот параметр ставьте всегда как ноль - "0".
	И так параметры:
	(SS|MM|HH|DD|MO|YR|WW)
	SS - секунды (0-60)
	MM - минуты  (0-60)
	HH - часы    (0-23)
	DD - день месяца (1-{28,30,31})
	MO - месяц, его номер (1-12)
	YR - год, формат 4-х значный (2002)
	WW - номер дня в неделе:
		    1) понедельник
		    2) вторник
		     ...
		    6) суббота
		    7) воскресение
	Как работает:
	каждый параметр может содержать символ '*' это значит любой,
	если такой символ будет содержать часы то значит в любой час,
	месяцы то в любой месяц, дни недели так же любыми будут.
	10-31/2 - если данная запись стоит в параметре для дня то
	          это означает что с числа 10 по 31 число, каждые два дня.
	*/2	- если данная запись стоит к примеру в части для часов
	    	  то это означает что каждые 2 часа.
	записи могут быть и такими:
	10-31/4,*/5,1,18,24	- если такая строка находится в параметре дня
				  то это означает что с числа 10 до 31 каждые 4
				  дня начинать новый файл, а так же каждые 5 дней
				  а так же 1 18 и 24 числах начинать новый файл.
	    пример:
	    (0|45|*/7|*|*|*|3-7) означает что каждые 7 часов 45 минут 0 сек.
				 со среды по воскресение начинать записывать в 
				 другой файл.
	    (0|0|0|*|*|*|*)	- Начинать новый файл с наступлением новых суток.
	    (0|12-45/2,23,58|*|*|*|*|*) - Начинать новый файл с 12 минут по 45
					  каждые 2 минуты. А так же на 23-ю минуту
					  и на 58 минуту.
	    (0|*|23-7/1,9|*|*|*|*)	- Начинать новый файл с 23 до 7 утра каждый час
					 и начать новый файл еще и в 9 утра.
	    (0|*|23-7/1,9|*|*|*|3,4)	- тоже самое что и выше но
					только с среду и четверг.
	    (*|*|*|_|*|*|*)		- символ "_" символизиурет начало, каждое
					новое значение. В данном случае статистика
					будет начинаться каждый новый день.
	    (*|*|_|*|*|*)		- в данном примере статистика начинаться
					будет каждый новый час, и так далее.					
	      stat_by_dev=(lo2,lo2,lo8,lo,lo3,lo4)+(/var/trafacct/loSD-1)+(o,i)+(nameSD)
	      stat_time_on=(nameSD)+(/var/trafacct/lo-staGL)+(0|*|23-7/1,9|*|*|*|0,3)+(ss,ss,mo,dd,yr,ww,hh,mm,ss)
	    Дальше идет третья часть после параметра формата времени
	    это дополнение к расширению файла
	    (ss,ss,mo,dd,yr,ww,hh,mm,ss)
	    ss,mo,dd,yr,ww,hh,mm,ss
	    это аббревиатура, только с маленькими буквами,
	    к тому что уже было рассказано для формата времени.
	    для представленного формата - (ss,ss,mo,dd,yr,ww,hh,mm,ss)
	    файл буде выглядеть так:
		lo-staGL.40.40.02.12.2002.06.06.44.40
	    расположение аббревиатура может вариироваться,
	    и количество тоже не фиксированно.
	    т.е. можно даже так (mm,mm,mm,dy,dy,yr,yr,ss)
	    как угодно.
    3. save_on_time
    
	Переменная имеет 1 параметр.
	Параметры:
	    1)	Строка с именем файла.
	Изначально для всех функций log_
	остановка программы и последующий ее запуск
	обнулял каунтеры(counters) для ф-ций log_
	и все, что там было ранее терялось безвозвратно.
	Но ф-ция save_on_time позволяет периодически
	сохранять статистику в указанный файл, а 
	при следующем старте восстанавливать оттуда
	все counters, и получится видимость что программа
	не была остановлена вообще.
	Первый параметр это путь к файлу,
	но следует иметь ввиду, что к имени файла
	будет приписано еще и имя интерфейса(его главное имя).
	Пример:
	save_on_time=(/var/trafacct/saved-conf-)	
	
	Если эту строку поместить в файл скажем "eth-conf"
	то результирующий файл для сохранения ЛОГов будет такой:
	"/var/trafacct/saved-conf-eth"
	его не желательно удалять, иначе при следующем старте
	ничего из него не восстановится. И его следует удалить
	если требуется при каком-то старте программы обнуление
	всех счётчиков.
    
	Так же данная функция имеет утилиту(cutdb), утилита предназначена
	для того чтобы в сохраненной базе можно было удалять записи для
	некоторых функций.
	К примеру вы используете в работе 2 функции log_file и
	log_by_each_ip, и вам нужно обнулить сохраненные значения
	для log_file но	оставить "нетронутой" функцию log_by_each_ip.
	Это можно сделать с помощью утилиты cutdb, которая может вырезать
	значения для указанной функции, и так вам просто нужно будет 
	запустить:
	bash# cutdb /var/trafacct/saved-conf-eth log_file
	
	но только перед этим не забудьте завершить работу Traffic Accounting,
	а после следующего старта значения для log_by_each_ip останутся
	"нетронутыми" а значения для log_file обнуляется.
    
    4. priority
    
	Данная функция изменяет приоритет для текущего процесса
	который обрабатывает определенный интерфейс.
	Наилучшим приоритетом для процесса является (-20).
	Пример:
	    priority=(-20)
	    Если данная строка вставлена в файл eth-conf тогда
	    процесс обрабатывающий eth интерфейс, получит приоритет (-20).

    5. ip_entry_list
	
	Данная переменная имеет 2 параметра.
	Параметры:
	    1) Максимальное колличество записей
	    2) Файл для результата
	    
	Данная функция используется для того чтобы узнать
	время первого и последнего "появления" для какого либо IP.
	Если какой то IP был "замечен" сразу же он записывается
	в таблицу к ip_entry_list и так же записывается время его обращения.
	Фактически посмотрев на таблицу можно будет узнать когда первый раз
	был "замечен" конкретный IP и когда был последний раз "замечен".
	Если в таблице не присутствуют искомые IP адреса и она не полная
	то IP адрес никогда не обращался к машине.
	Если таблица полная то первой строкой будет написано о том что 
	она полная.
	Формат лога описан в п. 11.
	Пример:
	ip_entry_list=(1000)+(/var/trafacct/ip_entry_list)

  4.2.6 Группа лимитов
    
    К данной группе относятся переменные, такие как:
    
    ip_range_traf_limit, ip_each_traf_limit,
    port_range_limit, each_port_limit,
    proto_range_limit, proto_each_limit,
    port_ip_limit, port_ip_each_limit,
    eport_eip_limit, proto_ip_limit,
    proto_ip_each_limit, eproto_eip_limit,
    iface_limit.
    
    Описание каждой из переменных.

    1.  ip_range_traf_limit
	
	Данная переменная имеет 4 параметра.
	Параметры:
	    1) Перечисление лимитов.
	    2) Перечисление IP адресов.
	    3) Имя программы.
	    4) Имя для переменной.
	    
	Перечисление лимитов выглядит следующим образом:
	    пример: (i#2304835,b#234234,f#9756735,o#9000000)
	    
		т.е. пишется тип трафика дальше ставится знак '#'
		и пишется лимит на колличество байт для этого типа трафика.
		Максимальное число которое можно указать в качестве
		лимита - 18446744073709551615.
		
	Пример:
	ip_range_traf_limit=(i#2304835,b#234234,f#9756735,o#9000000)+(a127.0.0.1-10)+(/bin/tprog %LT %IP %TP %LM)
	
	После того как лимит достигнут запускается программа
	указанная в третьем параметре.
	Имя программы выглядит следующим образом:
	    пример: (/bin/tprog %LT %IP %TP %LM %IN)
	    
		под %LT %IP %TP %LM подставляется следующее:
		
	    %LT - тип лимита:
	    
		"IR" - для переменной ip_range_traf_limit
		"IE" - для переменной ip_each_traf_limit
		"PR" - для переменной port_range_limit
		"PE" - для переменной each_port_limit
		"RP" - для переменной proto_range_limit
		"RE" - для переменной proto_each_limit
		"PA" - для переменной port_ip_limit
		"PB" - для переменной port_ip_each_limit
		"PC" - для переменной eport_eip_limit
		"PD" - для переменной proto_ip_limit
		"PE" - для переменной proto_ip_each_limit
		"PF" - для переменной eproto_eip_limit
		"IL" - для переменной iface_limit
		
	    %IP - в данной переменной для данного пример подставится:
		a127.0.0.1-10
		
	    %TP - это тип трафика лимит которого достигнут, он может быть:
		input     для "i"
		forward   для "f"
		broadcast для "b"
		multicast для "m"
		output    для "o"
		
	    %LM - это число лимита который был достигнут,
		    для данного примера и скажем для типа "i"
		    это будет - 2304835
		    
	    %IN - интерфейс.
	    
	И так после этого мы получим следующее:
	 например лимит был достигнут для типа "i", и переменная используется 
	 ip_range_traf_limit:
	 
	    /bin/tprog IR a127.0.0.1-10 input 2304835
	    
	Это будет значит что диапазон IP 127.0.0.1-10 достиг
	лимита в 2304835 байт для трафика input, т.е. всё это
	запустилось когда IP адреса диапазона 127.0.0.1-10
	получили 2304835 байт.
	А текст программы /bin/tprog может быть любой, или же
	скрипт:
	
	#--- CUT HERE ---
		
	#!/bin/bash
	
	if [ ${3} = "input" ]; then
	  echo диапазон IP адресов ${2} получил максимальное \
	    колличество байт, размером в LM:${4}, на интерфейсе ${5} \
		>> /var/log/limit.log;
	fi
	
	echo LT:${1} IP:${2} TP:${3} LM:${4} IN:${5} >> /var/log/limit.log;
	
	#--- END  CUT ---
	    
	После запуска программы значения лимита сбрасываются и 
	программа сново запустится как только лимит ещё раз будет достигнут.
	
	И так, для переменной ip_range_traf_limit допустимыми
	шаблонами являются:
	%LT, %IP, %TP, %LM, %IN.
	
	Функция предназначена контролировать лимиты трафика для
	диапазонов IP адресов.
	
    2.  ip_each_traf_limit
	
	Данная переменная имеет 4 параметра.
	Параметры:
	    1) Перечисление лимитов.
	    2) Перечисление диапазонов IP адресов.
	    3) Имя программы.
	    4) Имя для переменной.
	    
	Функция предназначена контролировать лимиты трафика
	для каждого IP адреса входящего в диапазон, который
	указан параметром 2.

	Допустимыми шаблонами являются:
	%LT, %IP, %TP, %LM, %IN.
	
	%IP для данной переменной будет содержать IP адрес который
	    достиг лимита.
	
	Пример:
	ip_each_traf_limit=(i#4000000,o#340958349)+(a127.0.0.1-10)+(/bin/tprog %LT %IP %TP %LM %IN)
	
	Программа может быть следующего содержания:
	
	#--- CUT HERE ---
	
	#!/bin/bash
	
	if [ ${3} = "input" ]; then
	    iptables -A OUTPUT -d ${2} -i ${5} -j DROP;
	fi
	
	#--- END  CUT ---
	
	Таким образом, когда IP адрес из диапазона получит 4000000 байт,
	то для него будет отключен внешний трафик.
	
    3.  port_range_limit
    
	Данная переменная имеет 5 параметров.
	Параметры:
	    1) Перечисление лимитов.
	    2) Номер протокола 6(TCP) или 17(UDP).
	    3) Перечисление диапазонов портов.
	    4) Имя программы.
	    5) Имя для переменной.
	    
	Функция предназначена контролировать лимиты для
	диапазона портов, на протоколах UDP и TCP.

	Допустимыми шаблонами являются:
	%LT, %TP, %LM, %IN, %PR, %PO.
	
	%PR - протокол, 17(для UDP) или 6(для TCP)
	%PO - диапазон портов, для примера может содержать "a1-60"
	
	Пример:
	port_range_limit=(i#900000,o#1009990)+(6)+(a1-60)+(/bin/tprog_port %LT %PR %PO %TP %LM)
	
	Из данного примера можно видеть, что программа /bin/tprog_port запустится
	только когда, когда будет достигнут лимит на input, и/или на output.	
	
    4.  each_port_limit
    
	Данная переменная имеет 5 параметров.
	Параметры:
	    1) Перечисление лимитов.
	    2) Номер протокола 6(TCP) или 17(UDP).
	    3) Перечисление диапазонов портов.
	    4) Имя программы.
	    5) Имя для переменной.

	Функция предназначена контролировать лимиты для
	каждого порта входящего в данный диапазон потов.
	
	Допустимыми шаблонами являются:
	%LT, %TP, %LM, %IN, %PR, %PO.
    
	%PO - для данной переменной будет содержать 
	      номер порта, который достиг лимита.
	      
	Пример:
	each_port_limit=(i#10000000)+(6)+(a1-80)+(/bin/tprog_port %LT %PR %PO %TP %LM %IN)
	
	Программа /bin/tprog_port запустится только тогда когда, 
	какой либо порт получит 10000000 байт трафика.
	
    5.  proto_range_limit

	Данная переменная имеет 4 параметра.
	Параметры:
	    1) Перечисление лимитов.
	    2) Перечисление протоколов.
	    3) Имя программы.
	    4) Имя для переменной.
	    
	Функция предназначена контролировать лимиты
	для диапазона протоколов, перечисленных 2-м параметром.
	
	Допустимыми шаблонами являются:
	%LT, %TP, %LM, %IN, %RP.
	
	%RP - будет содержать диапазон протоколов, который достиг
	      лимита, например "1-60" .
	
	Пример:
	proto_range_limit=(i#2049890,o#304958340)+(1-60)+(/bin/tprog_proto %LT %RP %TP %LM %IN)

	Программа /bin/tprog_proto запустится тогда когда диапазон портов
	достигнет лимит для трафика input и/или output.
	Т.е. когда отправлено будет 304958340 байт с диапазона 1-60
	и/или получено будет 2049890 байт.
	
    6.  proto_each_limit
    
	Данная переменная имеет 4 параметра.
	Параметры:
	    1) Перечисление лимитов.
	    2) Перечисление протоколов.
	    3) Имя программы.
	    4) Имя для переменной.
	    
	Функция предназначена контролировать лимиты для
	каждого протокола, который указан 2-м параметром.
	
	Допустимыми шаблонами являются:
	%LT, %TP, %LM, %IN, %RP.
	
	%RP - будет содержать номер протокола, который достиг лимита.
	
	Пример:
	proto_each_limit=(i#2049890,o#304958340)+(1-60)+(/bin/tprog_proto %LT %PR %TP %LM %IN)

	Программа /bin/tprog_proto может содержать следующее:

	#--- CUT HERE ---
	
	#!/bin/bash
	
	if [ ${3} = "input" ] && [ ${2} = "1" ]; then
	    echo трафик по ICMP достиг максимального лимита \
		в ${4} байт, на интерфейсе ${5} >> /var/log/limit.log;
	fi
		
	#--- END  CUT ---
    
    7. port_ip_limit
	
	Данная переменная имеет 6 параметров.
	Параметры:
    	    1) Перечисление лимитов.
	    2) Номер протокола 6(TCP) или 17(UDP).
	    3) Перечисление IP адресов.
	    4) Перечисление диапазонов портов.
	    5) Имя программы.
	    6) Имя для переменной.
	    
	Функция предназначена контролировать лимиты для
	диапазонов портов для диапазонов IP адресов.
	
	Допустимыми шаблонами являются:
	%LT, %IP, %TP, %LM, %IN, %PR, %PO.
	
	%IP - для данной функции содержит диапазон IP адресов.
	%PO - для данной функции содержит диапазон портов.	
	
	Пример:
	port_ip_limit=(i#2049890,o#304958340)+(6)+(a127.0.0.1-10)+(a1-60)+(/bin/tprog_pip %LT %PR %PO %IP %TP %LM %IN)
	
    8.  port_ip_each_limit
    
	Данная переменная имеет 6 параметров.
	Параметры:
    	    1) Перечисление лимитов.
	    2) Номер протокола 6(TCP) или 17(UDP).
	    3) Перечисление IP адресов.
	    4) Перечисление диапазонов портов.
	    5) Имя программы.	
	    6) Имя для переменной.
    
	Функция предназначена контролировать лимит для
	диапазонов портов для каждого IP адреса, который
	входит в диапазон, указанный 3-м параметром.
	
	Допустимыми шаблонами являются:
	%LT, %IP, %TP, %LM, %IN, %PR, %PO.
	
	%IP - для данной функции содержит IP адрес который
	    превысил лимит по диапазону портов.
	
	Пример:
	port_ip_each_limit=(i#2049890,o#304958340)+(6)+(a127.0.0.1-10)+(a1-60)+(/bin/tprog_pip %LT %PR %PO %IP %TP %LM %IN)

    9.  eport_eip_limit	

	Данная переменная имеет 6 параметров.
	Параметры:
    	    1) Перечисление лимитов.
	    2) Номер протокола 6(TCP) или 17(UDP).
	    3) Перечисление IP адресов.
	    4) Перечисление диапазонов портов.
	    5) Имя программы.	    
	    6) Имя для переменной.
	
	Функция предназначена контролировать лимит для
	каждого порта, который входит в диапазон, для 
	каждого IP адреса, который входит в диапазон.
	
	Допустимыми шаблонами являются:
	%LT, %IP, %TP, %LM, %IN, %PR, %PO.
	
	%PO - содержит номер порта который превысил лимит.
	
	Пример:
	eport_eip_limit=(i#50,b#123,f#56,o#1000)+(6)+(a127.0.0.1-10)+(a1-60)+(/bin/tprog_epeip %LT %PR %OP %IP %TP %LM %IN)
	
    10.  proto_ip_limit
	
	Данная переменная имеет 5 параметров.
	Параметры:
	    1) Перечисление лимитов.
	    2) Перечисление IP адресов.
	    3) Перечисление протоколов.
	    4) Имя программы.
	    5) Имя для переменной.
	    
	Функция предназначена контролировать лимиты
	диапазонов протоколов которые относятся к диапазонам IP адресов.
	
	Допустимыми шаблонами являются:
	%LT, %IP, %TP, %LM, %IN, %RP.
	
	%IP - как диапазон.
	%RP - как диапазон.
	
	Пример:
	proto_ip_limit=(i#50,b#123,f#56,o#1000)+(a127.0.0.1-10)+(1-60)+(/bin/tprog_prip %LT %RP %IP %TP %LM %IN)

    11. proto_ip_each_limit

	Данная переменная имеет 5 параметров.
	Параметры:
	    1) Перечисление лимитов.
	    2) Перечисление IP адресов.
	    3) Перечисление протоколов.
	    4) Имя программы.
	    5) Имя для переменной.
	
	Функция предназначена контролировать лимиты
	диапазонов протоколов для каждого IP адреса который
	входит в диапазон(ы) указанный 2-м параметром.
	
	Допустимыми шаблонами являются:
	%LT, %IP, %TP, %LM, %IN, %RP.
	
	%IP - как отдельный IP.
	
	Пример:
	proto_ip_each_limit=(i#50,b#123,f#56,o#1000)+(a127.0.0.1-10)+(1-60)+(/bin/tprog_prip %LT %RP %IP %TP %LM %IN)
	
    12. eproto_eip_limit
    
	Данная переменная имеет 4 параметров.
	Параметры:
	    1) Перечисление лимитов.
	    2) Перечисление IP адресов.
	    3) Перечисление протоколов.
	    4) Имя программы.
	    5) Имя для переменной.
	
	Функция предназначена контролировать лимиты
	каждого протокола для каждого IP адреса, которые
	входят в указанные диапазоны.
	
	Допустимыми шаблонами являются:
	%LT, %IP, %TP, %LM, %IN, %RP.
	
	%RP - как отдельный протокол.
	
	Пример:
	eproto_eip_limit=(i#50,b#123,f#56,o#1000)+(a127.0.0.1-10)+(1-60)+(/bin/tprog_prip %LT %RP %IP %TP %LM %IN)
	
    13. iface_limit
    
	Данная переменная имеет 4 параметра.
	Параметры:
	    1) Перечисление лимитов.
	    2) Перечисление интерфейсов.
	    3) Имя программы.
	    4) Имя для переменной.
	
	Функция предназначена контролировать лимиты
	каждого интерфейса.
	
	Допустимыми шаблонами являются:
	%LT, %TP, %LM, %IN.
	
	%IN - как отдельный интерфейс.
	
	Пример:
	iface_limit=(i#90000000,o#90000000)+(eth3,eth7)+(/bin/tprog_iface %LT %TP %LM %IN)
			
  4.3 Примеры готовых конфигураций
    
    В данном пункте приведены несколько примеров, готовых
    конфигураций управления трафиком.
    
    1. Для ppp интерфейса
    
    #--- CUT HERE ---
    ip_entry_list=(1000)+(/var/trafacct/IP-LIST-PPP)
    log_by_each_ip=(a200.100.10-24)+(/var/trafacct/TRAFFIC-PPP)+(a)
    full_stat_by_dev=(ppp4,ppp5,ppp6,ppp7,ppp8,ppp9)+(/var/trafacct/DUMP-PPP4-9)+(a)
    #--- END  CUT ---
    
    2. Для eth интерфейса
    
    #--- CUT HERE ---
    ip_entry_list=(1000)+(/var/trafacct/IP-LIST-ETH)
    log_by_each_ip=(a192.168.0.1-200)+(/var/trafacct/TRAFFIC-ETH-LAN)+(a)
    ls_by_iface=(skin_b.cf)+(/var/trafacct/ETH-ACCT)+(a)+(00|00|00|*/1|*|*|1,3,5)+(.%SS,%MM,%HH,%DD,%MO,%YR,%WW.html)
    #--- END  CUT ---
    
  4.4 Ошибки конфигураций
    
    Очень часто встречаются ошибки связанные с тем что некоторые
    параметры для разных или тех же переменных одинаковы.
    К примеру если для каких то двух переменных указать один и тот же
    файл, то писать в этот файл не будет никто, т.е. он будет пустым либо он
    будет в 2 раза больше чем нужно.
    Еще ошибки связанные с введением IP адресов, если для какой то
    переменной введены IP адреса но траффик по ним не считается, хоть
    деятельность этих IP адресов и наблюдается, то обычно где то в
    конфигурационном файле этот диапазон запрещен одной из переменной deny_.
    Для функций использующих время обновления, ошибки возникают когда
    в поле секунды стоит не 0 а символ '*', и при этом какие бы ни были 
    установлены остальные параметры статистика будет генерироваться каждую
    секунду. Поэтому если не требуется генерировать что-ли бо каждую секунду
    то это поле надо оставлять равным 0.
    
  5. Оптимизация конфигурации
  
    В данной части собраны некоторые сведения о том как
    улучшить конфигурацию программы Traffic Accounting, для
    того чтобы ускорит подсчёт трафика, если конечно ускорение
    необходимо.

  5.1 Оптимизация по скорости и размеру
    
    Можно оптимизировать конфигурационные файлы и по скорости
    и по размеру выходного результата.
    Когда речь идет об оптимизации по скорости необходимо
    точно знать конечную цель на результате подсчёта.
    Например нам необходимо подсчитать траффик локальной сети,
    это можно сделать либо функциями статистики либо функциями
    ведения лога.
    Для того чтобы считать по переменным статистики нужно иметь
    еще и внешнюю программу которая будет обрабатывать результат
    работы переменной.
    Но для того чтобы считать траффик с помощью функций ведения лога
    внешней программы не требуется.
    Поэтому лучше вместо записей вида:
    full_stat_global=(/var/trafacct/full_stat_global)+(a)+(full_stat_global)
    
    Использовать такие:
    log_by_each_ip=(a192.168.0.1-10)+(/var/trafacct/log_by_each_ip)+(a)+(log_by_each_ip)
    или
    ls_by_each_ip=(skin_a.cf)+(a192.168.0.1-10)+(/var/trafacct/ls_by_each_ip)+(i,o,b,f,m)+(*/10|*|*|*|*|*|*)+(.%SS,%MM,%HH,%DD,%MO,%YR,%WW.html)
    
    Два последний варианта работают гораздо быстрее.
    Еще один момент связанный со скоростью подсчёта трафика,
    еси всё же для подсчета необходимо использовать функции статистики,
    то лучше их использовать в конфигурационном файле как можно меньшее
    колличество раз.
    И так вместо такой записи:
    full_stat_global=(/var/trafacct/full_stat_global)+(a)+(full_stat_global)
    stat_global=(/var/trafacct/stat_global)+(a)+(stat_global)
    
    лучше использовать одну строку:
    full_stat_global=(/var/trafacct/full_stat_global)+(a)+(full_stat_global)
    
    Еще один момент для функций статистики, в любом случае
    лучше использовать такие переменные статистики которые хранят
    свои записи в бинарном формате. Бинарный формат ускоряет
    подсчёт в несколько раз.
    А преобразовывать бинарный формат в текстовый можно с помощью утилиты,
    которая входит в стандартный состав Traffic Accounting. Утилита
    называется tmlog, она описана в п. 12.

  5.2 Зависимость скорости
    
    Скорость еще сильно зависит от того сколько интерфейсов
    указано в главном конфигурационном файле, в строке dev=().
    Не указывайте там те интерфейсы которые не используются вообще,
    так как лишние замедляют подсчёт. Но данная зависимость,
    зависит от скорости и/или производительности процессора.
    
  6. Учёт трафика
  
    В данной части будут описанные несколько способов
    учёта трафика.
    
  6.1 Учёт по интерфейсам
    
    Учитывать траффик по интерфейсам, можно с помощью
    переменной log_file.
    записав ее как:
    log_file=(/var/trafacct/log_file)+(a)
    
    в результате можно видеть сколько пришло/ушло байт с/на интерфейс,
    т.е. посмотреть траффик для интерфейсов.
    Результат, в нашем случае, будет находится в файле /var/trafacct/log_file
    описание формата сохраненных данных можно посмотреть в п. 11.
    
    Так же для данной функции имеется ее клон с именем ls_by_iface,
    разница только в формате выходного результата и в том когда результат
    обновляется.
    например записав так:
    ls_by_iface=(skin_b.cf)+(/var/trafacct/ls_by_iface)+(a)+(00|00|*/2|*|*|*|1-5)+(.%SS,%MM,%HH,%DD,%MO,%YR,%WW.html)
    
    в файле /var/trafacct/ls_by_iface будет каждые 2 часа c понедельника по
    пятницу, сохраняться результат.
    
  6.2 Учёт по IP адресам
  
    Учитывать траффик по IP адресам позволяет функция log_by_each_ip.
    Если записать ее как:
    log_by_each_ip=(a192.168.0.1-10)+(/var/trafacct/log_by_each_ip)+(a)

    то в результате можно увидеть траффик для локальной сети в
    диапазоне IP адресов от 192.168.0.1 до 192.168.0.10 .
    Результат будет находиться в файле, в нашем примере файл 
    /var/trafacct/log_by_each_ip, и будет видно сколько пришло/ушло
    с/на отдельный IP адрес из диапазона 192.168.0.1-10 .
    Формат файла описан в п. 11.
    
    Есть еще одна функция которая позволяет считать траффик по IP
    адресам, эта функция log_by_ip, но данная функция считает не
    по отдельным адресам, а сразу по указанному диапазону.
    Поэтому если нет необходимости подсчитывать траффик по отдельным
    IP адресам то можно подсчитать по всему диапазону в целом,
    например так:
    log_by_ip=(a192.168.0.1-10)+(/var/trafacct/log_by_ip)+(a)
    
    после этого в файле /var/trafacct/log_by_ip, будет виден траффик
    для диапазона 192.168.0.1-10 .
    
    Еще есть функция отчётов ls_by_each_ip, она работает так же как и
    log_by_each_ip разница только в формате результата и во времени
    обновления результата. Функция ls_by_each_ip может сохранять
    отчёты как в текстовом так и в html и в другом формате, зависит
    от того какой скин используется, подробнее о скинах в п. 9.
    Например запись:
    ls_by_each_ip=(skin_a.cf)+(a192.168.0.1-10)+(/var/trafacct/ls_by_each_ip)+(i,o,b,f,m)+(00|00|00|*|*|*|*)+(.%SS,%MM,%HH,%DD,%MO,%YR,%WW.html)
    
    Позволит вести отчёт о трафике для отдельных IP адресов диапазона
    192.168.0.1-10, при этом обновляя результат каждые новые сутки.

  6.3 Учёт по протоколам
  
    Traffic Accounting может учитывать траффик по протоколам.
    Под протоколами понимаются не сервисы, которые находятся
    на портах TCP или UDP, а именно протоколы типа TCP, UDP,
    ICMP, и так далее.
    
    Для подобного учёта имеется несколько функций, мы не будем
    рассматривать их все, так как нет смысла, отличаются функции
    только параметрами.
    И так рассмотрим переменную log_by_proto.
    Если записать ее как:
    log_by_proto=(1,17,6)+(/var/trafacct/log_by_proto)+(a)
    
    то после этого, мы можем увидеть в файле /var/trafacct/log_by_proto
    как результат, траффик по протоколам 1,17,6(ICMP, UDP, TCP)
    все номера стандартны для протоколов, и описаны в п. 4.2.2 .
    
    Для того чтобы подсчитать отдельный траффик для отдельных
    протоколов нужно использовать переменную log_by_each_proto.
    Если записать ее как:
    log_by_each_proto=(1,17)+(/var/trafacct/log_by_each_proto)+(i,o,b,f,m)+(log_by_each_proto)
    
    и тогда в результате в файле /var/trafacct/log_by_each_proto, будет виден
    траффик для отдельных протоколов(сколько пришло/ушло).
    
    Остальные функции можно посмотреть из описания их в п. 4.2.2.
    
  6.4 Учёт по портам
    
    Траффик можно учитывать по портам используя несколько
    функций, но мы рассмотрим только некоторые, самые главные(базовые)
    из них.
    Переменная log_by_port, позволит увидеть траффик по диапазону
    портов для протокола TCP или UDP.
    Запись:
    log_by_port=(17)+(a1-65535)+(/var/trafacct/log_by_port)+(b,f,m,i,o)+(log_by_port)
    
    позволит увидеть в файле /var/trafacct/log_by_port, траффик по диапазону
    портов 1-65535, для протокола UDP.
    
    Еще одна функция она подсчитывает траффик по портам, но не в общем
    по диапазону а по отдельному порту входящему в указанный диапазон.
    Это функция записывается как:
    log_by_each_port=(6)+(a1-65535)+(/var/trafacct/log_by_each_port)+(b,f,m,i,o)+(log_by_each_port)
    
    и в результате можно увидеть будет в файле /var/trafacct/log_by_each_port,
    траффик для отдельного порта из диапазона 1-65535, протокола TCP, например
    траффик WEB сервера или траффик FTP.
    
    Форматы описаны в п. 4.2.2 .
    
  6.5 Учёт по каждому пакету
  
    Данный учёт самый простой, он заключается в том 
    чтобы заносить каждый пакет в файл.
    Для этого используется много переменных(все они описаны в п 4.2.1)
    но базовыми являются некоторые, это например stat_global.
    Если записать её как:
    stat_global=(/var/trafacct/stat_global)+(a)
    
    то в файл /var/trafacct/stat_global будет записываться каждый пикет,
    с его структурой. Формат файла описывается в п. 11.
    Есть еще одна функция full_stat_global, разница только в формате
    для каждого пакета, у full_stat_global он более полный чем у stat_global.
    
    Так же для скорости ведения статистики существуют прототипы для 
    переменных статистики, такие прототипы начинаются с bin_, 
    и на выходе у них бинарный формат, который можно преобразовать
    в текстовый утилитой tmlog описанной в п. 12.
    Функции bin_ занчительно ускоряют работу "сбора" пакетов.
    Например:
    bin_full_stat_global=(/var/trafacct/bin_full_stat_global)+(a)
    
    В файл /var/trafacct/bin_full_stat_global будет заносится бинарные
    записи.
    
    Формат записей для каждой функции описан в п. 11.
    
    
  7. Тесты работы Traffic Accounting
   
    В данном разделе представлены некоторые результаты работы,
    Traffic Accounting. А так же сравнение версий по функциональности
    и скорости.
    
  7.1 Тесты версий
    
    На данный момент последняя версия 1.1.0 обрабатывает,
    ~5000 пакетов в секунду на 266Mhz Intel Pentium-II.
    Остальные версии немного отстают в подсчётах, почему это так,
    объясняется в п. 7.2 .
    
  7.2 Сравнение версий
    
    Отличия последней версии 1.1.0 от предыдущих:
    
    1. Функциональность
      
      Добавлено большое колличество новых функций(переменных),
      колличество в общем которых теперь составляет 60.
      Это к примеру на 16 функций больше чем предпоследняя версия.
      
    2. Скорость
      
      Проведена наиполнейшая оптимизация для всех функций и всего
      кода Traffic Accounting в общем. Оптимизация проводилась
      по скорости.
      Сделан буффер на 10,000 пакетов который освобождается только
      тогда когда колличество пакетов в нем становится 10,000 .
      Раньше каждой функции статистики, приходилось записывать
      каждый новый пакет в файл в то время когда он пришел.
      Представьте если в секунду приходило по 3000 пакетов то в
      секунду приходилось делать 3000 записи в файл. Это отнимало
      огромно колличество времени и производительности. Но теперь
      в Traffic Accounting 1.1.0 есть буффер и производительность
      возросла в несколько раз, так как запись на диск происходит
      после того как принято 10,000 пакетов.
      О том как обнулять буффер "вручную" описано в п. 8.
  
  8. Дополнительные возможности TA
    
    В данном пункте описаны некоторые возможности программы
    Traffic Accounting которые не касаются настроек
    конфигурационных файлов.
    
  8.1 Параметры командной строки
  
    В данной части документа описаны параметры командной
    строки для Traffic Accouting.
    
    Параметры.
    
    1. --server
      
      Данный параметр переключает Traffic Accounting в
      режим сервера. Значением к данному параметру должен
      быть порт, подробнее о режиме сервера в п. 9.
      Пример использования:
      
      bash# ./ta --server 5
      
    2. --cfile
      
      Данный параметр указывает на главный конфигурационный
      файл. Если данный параметр опущен то главный конфигурационный
      файл Traffic Accouting будет использовать /etc/ta.conf.
      Пример использования:
      
      bash# ./ta --cfile /etc/ta123.conf
      
    3. --pfile
    
      Данный параметр используется для указания пути к файлу,
      с базой пользователей для аунтефикации на сервер Traffic Accounting.
      Пример использования:
      
      bash# ./ta --pfile /etc/ta12passwd.db
      
  8.2 Опустошение буффера
  
    Если в конфигурационном файле управления трафиком используются
    функции из группы статистики, то для того чтобы преждевременно
    (не дожидаясь накопления 10,000 пакетов) записать буффура на диск,
    необходимо послать сигнал kill с типом USR1 для демона TA.
    Это нужно если трафика к примеру нету, и пришло всего 6 пакетов
    то в файлах для результата их не будет, и чтобы их туда записать
    нужно преждевременно сбросить буфер, например так killall -USR1 ta .
    Всё это возможно начиная с версии 1.1.0 .

  9. Режим сервера
    
    В данном пункте рассказывается о работе Traffic Accounting
    в режиме сервера, и рассказывается от начала до конца как
    перевести TA в режим сервера и как с ним потом работать.
    
  9.1 Информация
  
    Traffic Accounting в режиме сервера может считать траффик,
    с машины на которой он не запущен, например с роутера который
    находится в совершенно другой сети, или просто на другой машине.
    Так как Traffic Accounting предназначен для запуска только на Linux,
    можно решить и эту проблему, запустив его под Linux как сервер а 
    клиента запустить под другой Unix-подобной ОС. Клиент написан
    на языке как Assembler так и C.
    
  9.2 Необходимые настройки
  
    Для того чтобы считать траффик с удаленной машины нужно
    настроить главный конфигурационный файл ta.conf(к примеру)
    так как будто Traffic Accounting запущен именно на той удаленной
    машине.
    Дальше когда указаны необходимые настройки нужно прописать
    в главный конфигурационный файл строку server_port=(6)
    в нашем примере порт равен 6.
    Дальше всё зависит от количества интерфейсов указанных в 
    строке dev=(), если указано например:
    dev=(lo,ppp,eth)
    то так как начальный порт в нашем примере равен 6 тогда
    для lo порт будет 6, для подсчёта ppp порт будет 7, и для
    eth порт будет 8, и так далее если интерфейсов больше.
    в итоге к примеру может получится такой файл:
    
    #-- ta.conf --
    dev=(lo,ppp,eth)
    dir=(/etc/ta)
    mlog=(/var/log/ta.log)
    spec_ch=(|)
    skin_path=(/etc/ta/skins)
    server_port=(6)
    #-- ta  end --
    
    Вместо строки server_port можно так же просто запустить
    Traffic Accounting с параметром "--server 6".
    Например:
    
    bash# ./ta --server 6
    
    В этом случае строку server_port можно убрать.
    
    После того как вы запустили Traffic Accounting в режиме
    сервера, он открывает столько портов сколько присутствует
    интерфейсов, порты открываются по порядку начиная с начального
    порта указано либо строкой server_port=() либо параметром --server 6 .
    Например если указано 3 интерфейса а начальный порт равен 6, то
    откроются 3 порта 6,7,8.

  9.4 Создание аккаунта
    
    Для того чтобы к серверу TA могли коннектиться клиенты,
    необходимо с помощью утилиты tuseradd создать аккаунты.
    
    При создании аккаунтов создается файл /etc/passwd.db, но
    путь его можно поменять используя параметр к программе 
    tuseradd, подробнее в п. 12.
    Все аккаунты хранятся в RC6+MD5 шифровании.
    И так создаем аккаунт:
    
    bash#tuseradd -a test
    Changing password for user
    New password:
    
    вводим пароль и на этом создание аккаунта закончено.
    
    Если необходимо создавать аккаунты в другом файле то его можно
    указать параметром --pfile, tuseradd -a test --pfile /etc1234/12345.db
    но этот параметр должен быть указан и для
    TA, ./ta --pfile /etc1234/12345.db

    На этом операции с сервером заканчиваются, естественно нужно
    как обычно подготовить eth-conf, lo-conf, ppp-conf если такие 
    требуются.

  9.5 Запуск в режиме сервера
  
    И так, чтобы запустить Traffic Accounting в режиме
    сервера нужно просто запустить его:
    
    bash# ./ta;
    
    но если вы не указали строку server_port в ta.conf,
    то запускать нужно так:
    
    bash# ./ta --server 6;
    
    После этого Traffic Accounting переходит в режим сервера.
    
  9.6 Запуск клиента
  
    Далее нам необходимо на удаленной машине нам нужно запустить клиент для
    TA, клиент обычно должен находится в каталоге tools/tsclient с названием
    tsclient. Берем оттуда клиент, дальше просто запускаем его на той
    машине:
    
    bash#./tsclient -s <IP_TA_SERVER> -p <PORT> --user <USER> --pass <YOURPASS>
    
    <IP_TA_SERVER> = 192.17.28.34, к примеру, это должен быть IP на котром запущен
				   сервер TA.
    <PORT> = 5, порт для коннекта, например если вам надо считать траффик для
	    eth интерфейса то порт тогда нужен будет 6, так как 
	    мы запускали ta с начальным портом 5, а в конфиге глобальном
	    eth стоит на втором месте:
	    dev=lo,eth,ppp
	        5   6   7
	    Так же и для ppp порт будет равен 7.
    <USER> = имя котрое создано на сервере с помощью tuseradd.
    <YOURPASS> = так же и пароль для имени.
    
    после этого, если всё правильно траффик будет считаться, можно
    в режиме daemon переключить клиент, чтобы он не висел на консоли
    для этого надо добавить параметр -d :
    
    bash#./tsclient -d -s <IP_TA_SERVER> -p <PORT> --user <USER> --pass <YOURPASS>
  
    И так надо запустить клиент для каждого интерфейса, если их несколько,
    т.е. по клиенту на каждый нужный порт, который выделен сервером TA для 
    отдельного интерфейса.
    
  10. Скины
    
    В данном пункте будет рассказано о том что такое скины в 
    программе Traffic Accounting, для чего они используются.
    Рассказывается о том как их конфигурировать и где использовать.
  
  10.1 Для чего?
  
    Начиная с версии 1.1.0 скины используются для функций генерации
    отчётов. В прошлых версиях скины нигде нельзя использовать.
    В функциях генерации отчётов отчёты должны выдаваться в таком
    виде в каком нужно каждому человеку, но под каждого подстроить
    один и тот же вид будет задачей сложной и поэтому чтобы не использовать
    один и тот же стиль для отчётов были введены скины. С помощью скинов
    можно придать отчётам любой вид и любое содержание, по стандарту
    в отчётах используется html код.
    Формат как уже говорилось можно придать любой, html, php, или просто
    текст, и так далее.

  10.2 Переменные скинов
  
    Для каждого элемента в используемого в отчёте, необходимо
    обозначить определенный скин, если какой то элемент остался
    не описанным то скин для него берется тот который по умолчанию.
    
    Переменные для создания скинов.
    
    1. ip_skin
    
      Данная переменная используется для задания скина для
      IP адреса, каждый IP адрес который будет выводится в 
      отчёт будет иметь тот скин который будет задан именно
      переменной ip_skin. Чтобы указать конкретное место для
      строки с IP адресом нужно вставить строку %IP .
      Пример:
      ip_skin=(<font color=red size=+1><b>%IP</font></b>)
      
    2. dev_skin
    
      Данная переменная используется для задания скина для
      интерфейса. После задания скина каждый выводимый
      в отчёт интерфейс будет со скином заданным переменной
      dev_skin. Что бы задать конкретное место расположения
      строки с интерфейсом, необходимо вставить в нужное место
      строку %DV.
      Пример:
      dev_skin=(<font color=blue size=+1><b>%DV</font></b>)
      
    3. io_skin
    
      Данная переменная используется для задания скина для
      выводимой в отчёт информации о трафике. Для того чтобы
      указать конкретное место положение информации можно
      использовать строки:
       %I - input
       %O - output
       %B - broadcast
       %M - multicast
       %F - forward
      Пример:
      io_skin=(<font color=blue size=+1><b>i:%I,o:%O,b:%B,m:%M,f:%F</font></b>)
      
    4. head_skin
    
      Если данная переменная используется то тогда то что
      указано в ее параметре будет как заголовок на выходе
      в отчёте. Другими словами всё что указано в данной переменной
      в отчёт добавляется первыми строками.
      Пример:
      head_skin=(<html><head><title>Traffic Accounting</title></head><body bgcolor="#cccc99">)
      
    5. end_skin
    
      Если данная переменная присутствует то тогда то что указанное
      в её параметре добавляется в конец файла результата.
      Пример:
      end_skin=(</body></html>)
      
    6. table_skin
    
      В отчёт добавляются две части записей, первая это
      состояние текущего трафика, а вторая часть это общий траффик.
      Каждая из этих двух частей описывается в отдельной таблице.
      И так то что указано в параметре к данной переменной будет
      использоваться как начало для таблицы.
      Пример:
      table_skin=(<table border="2" align="center">)
      
    7. table_end_skin
    
      Так как таблица может начинаться тогда они должна и чем-то
      закончится. Тогда то что будет в параметре для данной 
      переменной будет и окончанием для таблицы.
      Пример:
      table_end_skin=(</table>)
      
    8. trow_skin
    
      В каждой таблице есть ряд и скины для рядов
      описываются именно данной переменной.
      Пример:
      trow_skin=(<tr>)
      
    9. tcol_skin
    
      В каждом ряду должны присутствовать элементы,
      каждый элемент начинается параметра для данной
      переменной.
      Пример:
      tcol_skin=(<td>)
      
    10. end_trow_skin
      
      Каждый ряд для таблицы как начинается так и заканчивается,
      а заканчивается он параметром из данной переменной.
      Пример:
      end_trow_skin=(</tr>)
      
    11. end_tcol_skin
    
      Каждый элемент в ряду начинается с tcol_skin, а заканчивается
      с параметром для данной переменной.
      Пример:
      end_tcol_skin=(</td>)
      
    12. cr_traf_skin
      
      Как уже говорилось в отчёт пишется информация
      о трафике состоящая из 2-х частей, при этом
      первая часть это текущий траффик а вторая часть 
      это общий траффик.
      Для каждой части перед таблицей должно идти название 
      таблицы, так вот параметр для данной переменной,
      это скин для называния таблицы с текущим трафиком.
      Пример:
      cr_traf_skin=(<b>Current Traffic:</b><br>)
      
    13. jt_traf_skin
    
      В отличии от cr_traf_skin, данная переменная
      используется для того чтобы указать скин для
      называния у таблицы общего трафика.
      Пример:
      jt_traf_skin=(<br><b>Joint Traffic:</b><br>)
      
    14. port_skin
      
      Данная переменная используется для задания скина
      номера порта.
      Пример:
      port_skin=(<font color=red size=+1><b>%PO</font></b>)
      
    15. proto_skin
    
      Данная переменная используется для задания скина
      к номеру протокола.
      Пример:
      proto_skin=(<font color=red size=+1><b>%PR</font></b>)
      
  10.3 Как работает?
    
    После того как вы могли увидеть переменные используемые
    для создания скинов, вы можете прочитать о том как их
    использовать.
    Все переменные перечисленные в п. 10.2 нужно писать в файле
    с расширением .cf , можно конечно придумать ваше по вкусу.
    Каталог в котором скины будут располагаться должен быть 
    описан переменной skin_path, в главном конфигурационном файле.
    Например: 
    skin_path=(/etc/ta/skins)
    
    И так, работает всё очень просто: функции отчётов, в общем
    не зависимо от того что к чему относятся отчёты, имеет 
    две части, текущий траффик и следующая часть общий.
    Текущий обнуляется каждый раз как придет время, обычно интервалы
    в функциях указываются, а то что было в текущей части до обнуления
    прибавляется к общему.
    Результаты для текущих функций отчётов следуют в следующей
    структуре, числами будут указаны части начиная с верху в низ:
        
    1. скин заголовка (head_skin)
    2. скин названия для части с текущим трафиком (cr_traf_skin)
    3. скин начала таблицы (table_skin)
     3.1 скин строки для таблицы (trow_skin)
      3.2 скин для части строки (tcol_skin)
       3.3 скин для IP адреса, если требуется (ip_skin)
       3.4 скин для интерфейса (dev_skin)
       3.5 скин для трафика (io_skin)
      3.6 скин окончания части строки (end_tcol_skin)
     3.7 скин для окончания строки (end_trow_skin)
    4. скин окончания таблицы (table_end_skin)
    5. скин названия для части с общим трафиком (jt_traf_skin)
    6. скин начала таблицы (table_skin)
     6.1 скин строки для таблицы (trow_skin)
      6.2 скин для части строки (tcol_skin)
       6.3 скин для IP адреса, если требуется (ip_skin)
       6.4 скин для интерфейса (dev_skin)
       6.5 скин для трафика (io_skin)
      6.6 скин окончания части строки (end_tcol_skin)
     6.7 скин для окончания строки (end_trow_skin)
    7. скин окончания таблицы (table_end_skin)
    8. скин окончания отчёта
    
  10.4 Примеры
  
    В данном случае представлены только два примера
    скинов, на результат их работы можете посмотреть сами.
    В стандартную поставку Traffic Accounting входят 4 скина,
    которые уже готовы к применению.
    
    Примеры скинов.
    
    1. Скин
    
    #--- cut here ---
    ip_skin=(<font color=red size=+1><b>%IP</font></b>)
    dev_skin=(<font color=blue size=+1><b>%DV</font></b>)
    io_skin=(<font color=blue size=+1><b>i:%I,o:%O,b:%B,m:%M,f:%F</font></b>)
    head_skin=(<html><head><title>Traffic Accounting</title></head><body bgcolor="#cccc99">)
    end_skin=(</body></html>)
    cr_traf_skin=(<center><font color=brown size=+2><b><i>Current</i> Traffic:</b><br></center></font>)
    jt_traf_skin=(<center><font color=brown size=+2><b><i>Joint</i> Traffic:</b><br></center></font>)    
    #--- end  cut ---

    2. Скин
    
    #--- cut here ---
    ip_skin=(<font color=red size=+1><b>%IP</font></b>)
    dev_skin=(<font color=blue size=+1><b>%DV</font></b>)
    io_skin=(<font color=blue size=+1><b>i:%I,o:%O,b:%B,m:%M,f:%F</font></b>)
    head_skin=(<html><head><title>Traffic Accounting</title></head><body bgcolor="#cccc99"><table align=center><tr>)
    end_skin=(</tr></table></body></html>)
    cr_traf_skin=(<td><center><font color=brown size=+2><b><i>Current</i> Traffic:</b><br></font></center></td><td><center><font color=brown size=+2><b><i>Joint</i> Traffic:</b><br></font></center></td></tr><tr>)
    table_skin=(<td><table border="2" align="center">)
    table_end_skin=(</table></td>)    
    #--- end  cut ---

  11. Форматы
    
    В данном пункте описаны различные форматы,
    в основном форматы результатов различных переменных.
  
  11.1 Группа статистики
    
    stat_global
    stat_by_dev
    stat_by_ip_global
    stat_by_ip_dev
	Используют лог файл вида:
	    +++---cut----
	    ppp0|s:212.188.98.212|d:195.34.32.10|l:57|t:output|949437591
	    ppp0|s:195.34.32.10|d:212.188.98.212|l:284|t:input|949437591
	    ppp0|s:212.188.98.212|d:194.67.57.105|l:60|t:output|949437591
	    ppp0|s:194.67.57.105|d:212.188.98.212|l:60|t:input|949437591
	    +++---cut----
	Первая часть это интерфейс, в данном примере это "ppp0"	    
	вторая часть это IP и его тип, т.е. строка "s:212.188.98.212"
	значит что 212.188.98.212 это source IP.
	Дальше идет длинна пакета, "l:57" значит длинна 57 байт.
	Следующая запись это тип пакета, здесь используется полное
	имя в данном примере это "output" и "input". Есть остальные
	forward, broadcast, multicast.
	Следующая часть это timestamp пакета, т.е. 
	время(в формате unix-time) в которое oн прибыл или уплыл.	

    full_stat_global
    full_stat_by_dev
    full_stat_by_ip_global
    full_stat_by_ip_dev    
    ----------------
	Использует ЛОГ вида:
	    +++---cut----	    
	     lo|s:127.0.0.1|d:127.0.0.1|l:84|t:input|ttl:255|proto:1|1016625962
	     lo|s:127.0.0.1|d:127.0.0.1|l:60|t:output|ttl:64|proto:6|sp:49894|dp:1|1016626131
	    +++---cut----
	    
	1) "lo", интерфейс
	2) "s:127.0.0.1", source ip, в нашем случае это "127.0.0.1".
	3) "d:127.0.0.1", destination ip, в нашем случае это "127.0.0.1".
	4) "l:84", длинна пакета, в данном примере это 84.
	5) "proto:1", протокол, в нашем случае "1" (ICMP).
	    Дальше если протокол не поддерживает ПОРТЫ то следующей
	    частью ЛОГа будет только timestamp:
		6) "1016625962" - timestamp
	    Если же протокол поддерживает ПОРТЫ то следующие части ЛОГа
	    будет выглядеть так:
		6) "sp:49894", source port, в нашем случае он равен "49894".
		7) "dp:1", destination port, в нашем случае он равен "49894".
		8) "1016626131" - timestamp

    bin_stat_global
    bin_stat_by_dev
    bin_stat_by_ip_global
    bin_stat_by_ip_dev
	Данные функции не записывают логи пакетов в текстовом
	виде, а записывают в бинарном формате.
	Формат:
	    struct entry {
		char[IFMAXNAME] name_iface_eo_zero; // например "eth8",0
		long	source_ip;
		long	destination_ip;
		long	length_of_packet;
		char	type_of_packet; // смотри "include/linux/if_packet.h"
					// для PACKET_HOST
					//PACKET_BROADCAST, PACKET_OUTGOING, и т.д.
		//и если используется timestamp, то
		//последним будет стоять время пакета
		//в unix time.
		long	time_stamp;
	    }

    bin_full_stat_global
    bin_full_stat_by_dev
    bin_full_stat_by_ip_global
    bin_full_stat_by_ip_dev
    --------------------
	Those functions is writes it`s entries not in
	a text format, but writes in binary format.
	Binary format of ne entry:
	    struct entry {
		char[IFMAXNAME] name_iface_eo_zero; //example: "eth8",0
		long source_ip;
		long destination_ip;
		long length_of_packet;
		char type_of_packet //см. "include/linux/if_packet.h"
				    //для PACKET_HOST, PACKET_BROADCAST, PACKET_OUTGOING, etc.
		char ttl;
		char protocol;
		/*
		    Если протокол поддерживает порты тогда следующий
		    байт будет равен "1".
			char port_supprt = 1;
		    и дальше entry выглядит так:
			short source_port;
			short destination_port;
						
		    Если протокол не поддерживает порты то следующий
		    байт будет равен "0".
			char port_supprt = 0;
		*/
		
		/*				    		    
		    Если следующий байт равен единице то
		    дальше идет параметр timestam, в unix-time
		    формате.
		    
		    char ts_flag = 1;
		    long	time_stamp;
		    
		    Если же char ts_flag = 0, то дальше 
		    больше параметром нет а значит окончание entry.
		    
		    char ts_flag = 0;
		*/
		
	    }    	
	    
  11.2 Группа ведения логов
    
    log_file
	Использует лог файл вида:
	
	    lo|i:392|b:0|m:0|f:0|o:392
	    
	Разделителем в этом примере является
	символ "|", но его можно изменить
	поправив, или указав в переменную 
	spec_ch в файле "ta.conf".
	И так его формат таков.
	Первая чать это интерфейс "lo",
	а следующие части это указанные типы
	пакетов и количество байт от этих пакетов.
	Например в данном примере использовалась строка
	log_file=(/var/trafacct/lo-log)+(i,o,f,b,m)
	Если какой-то типа пакета равен нулю, то
	либо этот пакет не перечислен, либо такой тип
	пакета, на указанный в первой части лог-файла интерфейс,
	не приходил.
	Максимальное количество байт которые могут быть "запомненны"
	это 64битное число = 0xffffffffffffffff = 18446744073709551615 байт.
	
    log_by_ip
	Использует ЛОГ файл вида:	
	
    	    lo|s127.0.0.5,d127.0.0.10-56|i:2268|b:0|m:0|f:0|o:2268
	
	Первая часть это интерфейс, вторая часть это перечисление диапазона
	IP адресов, остальные части описаны в log_file.
	Из данного примера мы можем видеть, что на диапазон
	"s127.0.0.5,d127.0.0.10-56" пришло байт 2268 а ушло с 
	диапазона 2268.
	
    log_by_each_ip
	Использует ЛОГ файл вида:	
	    +++---cut----
		lo|127.0.0.1|i:168|b:0|m:0|f:0|o:168
		lo|127.0.0.5|i:168|b:0|m:0|f:0|o:168
		lo|127.0.0.11|i:840|b:0|m:0|f:0|o:840
		lo|127.0.0.12|i:168|b:0|m:0|f:0|o:168
		lo|127.0.0.13|i:168|b:0|m:0|f:0|o:168
		lo|127.0.0.14|i:168|b:0|m:0|f:0|o:168
		lo|127.0.0.15|i:924|b:0|m:0|f:0|o:924		
	    +++---cut----
	Первая часть имя интерфейса, вторая часть IP адрес,
	остальные части относятся к отдельному IP адресу который
	находится во второй части, эти остальные части описываются
	и такие же как и в log_file.
	Из данного примера можно увидеть, что на IP 127.0.0.15 
	пришло 924 байта а ушло с этого IP 924 байта.
   
   log_by_port
	Использует ЛОГ файл вида:
	    +++---cut----
		lo|a1-65535|i:38|b:0|m:0|f:0|o:38
	    +++---cut----
	
	Первая часть это имя интерфейса.
	Следующая часть это диапазон портов по которым
	подсчитывается траффик.
	Остальные части это информация о трафике.
	
    log_by_each_port
	Использует ЛОГ файл вида:
	    +++---cut----
		lo|6#50|i:100|b:0|m:0|f:0|o:80
		lo|6#20|i:80|b:0|m:0|f:0|o:100		
	    +++---cut----
	    
	Первая часть это имя интерфейса.
	Следующая часть разделяется на две
	та часть что до символа '#' это протокол
	которому принадлежит порт, следующая часть
	это сам порт.
	Остальные части это информация о трафике.
	
    log_by_proto
	Использует ЛОГ файл вида:
	    +++---cut----
		lo|1,17|i:272|b:0|m:0|f:0|o:272
	    +++---cut----
	
	Первая часть это имя интерфейса.
	Следующая часть это протоколы по которым
	считается траффик.
	Остальные части это информация о трафике.
	
    log_by_each_proto
	Использует ЛОГ файл вида:
	    +++---cut----
		lo|proto:17|i:38|b:0|m:0|f:0|o:38
		lo|proto:1|i:234|b:0|m:0|f:0|o:234
	    +++---cut----
	
	Первая часть это имя интерфейса.
	Следующая часть это номер протокола.
	Остальные части это информация о трафике для 
	протокола.
	
    log_by_port_ip
	Использует ЛОГ файл вида:
	    +++---cut----
		lo|a127.0.0.1-40|a1-65535|i:140|b:0|m:0|f:0|o:140
	    +++---cut----
	
	Первая часть это имя интерфейса.
	Следующая часть это диапазон IP адресов для
	портов которых, перечисленных следующим параметром,
	считается траффик.
	Остальные части это информация о трафике.
	
    log_by_port_ip_each
	Использует ЛОГ файл вида:
	    +++---cut----
		lo|127.0.0.8|a1-65535|i:100|b:0|m:0|f:0|o:0
		lo|127.0.0.1|a1-65535|i:40|b:0|m:0|f:0|o:140
	    +++---cut----
	    
	Первая часть это имя интерфейса.
	Следующая часть это IP адрес для портов котрого,
	перечисленных следующим параметром, считается траффик.
	Остальные части это информация о трафике.
	
    log_by_eport_eip
	Использует ЛОГ файл вида:
	    +++---cut----
		lo|127.0.0.1->127.0.0.8|6#50|i:100|b:0|m:0|f:0|o:0
		lo|127.0.0.1->127.0.0.8|6#20|i:0|b:0|m:0|f:0|o:100
		lo|127.0.0.1->127.0.0.1|6#20|i:80|b:0|m:0|f:0|o:0
		lo|127.0.0.1->127.0.0.1|6#50|i:0|b:0|m:0|f:0|o:80	    
	    +++---cut----
	    
	Первая часть это имя интерфейса.
	Дальше лог читается как,например для первой строки,
	с адреса 127.0.0.1 на порт 50, протокола 6, адреса 
	127.0.0.8, пришло 100 байт.
	Для следующей строки читается как
	с адреса 127.0.0.1 с порта 20, протокола 6, на адрес
	127.0.0.8, ушло 100 байт.
	
    log_by_each_ip_local
	см. log_by_each_ip
	
    log_by_ip_local
	см. log_by_ip
	
    log_by_proto_ip
	Использует ЛОГ файл вида:
	    +++---cut----
		lo|a127.0.0.1-10|1,17|i:376|b:0|m:0|f:0|o:376
	    +++---cut----
	
	Первая часть это имя интерфейса.
	Вторая часть это диапазон IP адресов,
	для протоколов которых,перечисленных следующим
	параметром, считается траффик.
	Остальные части это информация о трафике.
	
    log_by_proto_ip_each
	Использует ЛОГ файл вида:
	    +++---cut----
		lo|127.0.0.8|1,17|i:76|b:0|m:0|f:0|o:132
		lo|127.0.0.1|1,17|i:300|b:0|m:0|f:0|o:244
	    +++---cut----
	
	Первая часть это имя интерфейса.
	Следующая часть это IP адрес для протоколов котрого,
	перечисленных следующим параметром, считается траффик.
	Остальные части это информация о трафике.    
	
    log_by_eproto_eip
	Использует ЛОГ файл вида:
	    +++---cut----
		lo|127.0.0.8|proto:17|i:76|b:0|m:0|f:0|o:0
		lo|127.0.0.1|proto:17|i:0|b:0|m:0|f:0|o:76
		lo|127.0.0.1|proto:1|i:300|b:0|m:0|f:0|o:168
		lo|127.0.0.8|proto:1|i:0|b:0|m:0|f:0|o:132		
	    +++---cut----
	
	Первая часть это имя интерфейса.
	Следующая часть это IP адрес для протокола которого,
	перечисленного следующим параметром, считается траффик.
	Остальные части это информация о трафике.

    full_log_by_each_ip
	Использует ЛОГ файл вида:
	    +++---cut----
		lo|127.0.0.1->127.0.0.8|i:176|b:0|m:0|f:0|o:176
		lo|127.0.0.1->127.0.0.1|i:40|b:0|m:0|f:0|o:40
		lo|127.0.0.8->127.0.0.1|i:132|b:0|m:0|f:0|o:132
		lo|127.0.0.10->127.0.0.10|i:168|b:0|m:0|f:0|o:168
		lo|127.0.0.9->127.0.0.9|i:168|b:0|m:0|f:0|o:168
		lo|127.0.0.7->127.0.0.7|i:168|b:0|m:0|f:0|o:168
		lo|127.0.0.6->127.0.0.6|i:168|b:0|m:0|f:0|o:168
		lo|127.0.0.5->127.0.0.5|i:168|b:0|m:0|f:0|o:168
	    +++---cut----
	
  11.3 Группа отчётов

    Если используется отчёт с применением скинов
    то см п. 10.2, 10.3 .
    Если же используется текстовый отчёт, то
    каждый такоё отчёт внутри разделён на две части.
    Текущий отчёт начиначется со строки "#current", 
    а общий отчёт начинается со строки "#joint".
    Для функций из группы отчётов которые имеют "клонов"
    по вормату в группе ведения лога, о формате можно
    прочитать именно из описания группы лога.
    Далее следует описание форматов тех функций
    которые не имеют клонов в группе лога, или
    их формат не описан.
    
    ls_by_eproto_ip

	Использует ЛОГ файл вида:
	    +++---cut----
	#current
	lo|a127.0.0.1-10,a127.0.0.15|proto:6|i:8925830|b:0|m:0|f:0|o:3070330
	lo|a127.0.0.1-10,a127.0.0.15|proto:1|i:1028|b:0|m:0|f:0|o:397836
	#joint
	lo|a127.0.0.1-10,a127.0.0.15|proto:6|i:8925830|b:0|m:0|f:0|o:3070330
	lo|a127.0.0.1-10,a127.0.0.15|proto:1|i:1028|b:0|m:0|f:0|o:397836	    
	    +++---cut----
        
	Возьмём первую строку.
	Первая чать "lo", это интерфейс, следующая часть
	это диапазон IP адресов, указанных для данной функции,
	далее идет протокол, для нашей строки он равен 6(TCP).
	Остальные части это информация о трафике.

    ls_by_eport_ip

	Использует ЛОГ файл вида:
	    +++---cut----
	#current
	lo|a127.0.0.1-10,a127.0.0.15|17#173|i:0|b:0|m:0|f:0|o:0
	lo|a127.0.0.1-10,a127.0.0.15|17#35636|i:0|b:0|m:0|f:0|o:0
	lo|a127.0.0.1-10,a127.0.0.15|17#1489|i:0|b:0|m:0|f:0|o:0
	lo|a127.0.0.1-10,a127.0.0.15|17#7007|i:0|b:0|m:0|f:0|o:0	
	#joint
	lo|a127.0.0.1-10,a127.0.0.15|17#173|i:56|b:0|m:0|f:0|o:0
	lo|a127.0.0.1-10,a127.0.0.15|17#35636|i:0|b:0|m:0|f:0|o:45500
	lo|a127.0.0.1-10,a127.0.0.15|17#1489|i:168|b:0|m:0|f:0|o:0
	lo|a127.0.0.1-10,a127.0.0.15|17#7007|i:56|b:0|m:0|f:0|o:0	
	    +++---cut----
        
	Возьмём первую строку.
	Первая чать "lo", это интерфейс, следующая часть
	это диапазон IP адресов, указанных для данной функции,
	далее идет описание порта оно = "17#173", это описание
	делится на 2 части, первая часть это 17, данная часть
	указывает какому протоколу принадлежит порт, вторая часть,
	это 173, данная часть это уже сам порт.
	Остальные части это информация о трафике.

	
  12. Утилиты
  
    Данный пункт посвящен описанию утилит, поставляемых
    в стандартном дистрибутиве Traffic Accounting.

    1. tmlog
    
	Используется для конвертации, формата binary в текстовый
	из логов от функций full_bin_stat*, bin_stat*...
	Подробнее см. файл "COMMANDL-RUS.text".
	
    2. tsclient
    
	Клиент к серверу Traffic Accounting.
	подробнее см. файл "SERVER-RUS.text".
    
    3. tuseradd
    
	Программа манипулирования файлом аунтецикации
	для сервера Traffic Accounting.
	
    4. cutdb
    
	Предназначена для функции save_on_time, cutdb может
	вырезать значения для указанных функций оставляя при этом
	другие сохраненные значения для других функций, нетронутыми.
	
	Описание применения в пункте 4.2.5, в описании save_on_time.	
    
    
  12.1 Подробное описание
  
    1. ta
    
	[--server]: переключает в режим сервера,
		  назначает начальный порт как параметр к --server.
	    example:
		bash# ./ta --server 5
		    Переключить и назначить начальный порт как 5.
	
	[--cfile]: указывает путь на главный конфигурационный файл.
	    example:
		bash# ./ta --cfile /etc/ta123.conf
		
	[--pfile]: указывает путь на файл с аккаунтами для аунтефикации
		   на сервер.
		   
	    example:
		bash# ./ta --pfile /etc/ta12passwd.db
		
    2. tuseradd
    
	[-a]: добавить пользователя, 
	      следующий параметр это имя пользователя.
	    example:
		bash# ./tuseradd -a test
		
	[-d]: удалить пользователя из базы,
	      следующим параметром идет имя пользователя для удаления.
	    example:
		bash# ./tuseradd -d test
		
	[-p]: изменить пароль для пользователя,
	      следующим параметром идет имя пользователя, для смены пароля.
	    example:
		bash# ./tuseradd -p test
	[--pfile]: указывает на путь к базе паролей для изменения,
		   стандартно она располагается в /etc/passwd.db
	    example:
		bash# ./tuseradd --pfile /etc/tapasswd8.db
    
    3. tsclient
    
	[-s]: IP адрес сервера на котором запущен Traffic Accounting.
	    example:
		bash# tsclient -s 195.23.78.4 -p 6 --user test
		
	[--user]: имя пользователя которое будет использоваться для
		  аунтефикации.
	    example:
		bash# tsclient --user test -s 195.23.78.4 -p 6 
	
	[--pass]: пароль для имени пользователя, если этот параметр
		  не указан то он запрашивается с ввода.
	    example: 
		bash# tsclient -pass mypassword --user test -s 195.23.78.4 -p 6 
	
	[-p]: параметр указывает порт для коннекта.
	    example:
		bash# tsclient -p 6 --user test -s 195.23.78.4 
	[-d]: если данный параметр присутствует то tsclient работает
	      в daemon режиме.
    4. tmlog
    
	[-f]: Этот параметр указывает какой вид формата ЛОГА
	      мы будем использовать, форматы могут быть:
	      b: binary (для всех bin_stat_ функций)
	      bf: full binary (для всех all full_bin_stat_ функций)
	[-p]:
	      Какую функцию нужно выполнить:
	      t: переконвертировать из binary в текстовый формат.	      
	[-o]:
	      Выходной файл, файл результата, если он не указан
	      то будет использоваться stdout.
	[-i]: 
	      Входной файл, файл над которым будут производится операции.
	[--data]:
	      Строка с датой, если данный параметр присутствует то выводятся
	      только те пакеты timestamp которых совпадает с датой, описанной
	      параметром.
	      **Формат строки с датой описан в файле CONFIGS-RUS.text,
	        дальше в описании к функции stat_time_on .
	[--ptype]:
	      Данный параметр указывает какой тип пакетов требуется выводить.
	      Типы могу быть:
	    	    	input, output, broadcast, multicast, forward.
	[--proto]:
	      Данный параметр используется для того чтобы выводить пакеты
	      с определенным протоколом, протокол должен быть указан как номер
	      к примеру, TCP=6, ICMP=1, UDP=17.
	      Такой параметр можно использовать только для полной статистики,
	      так как в неполной не указывается протокол.
	[--sport]:
	      Если данный параметр присутствует то на выход будут поданы все
	      пакеты у которых исходный порт равен указанному  параметру.
	[--dport]:
	      Если данный параметр присутствует то на выход будут поданы все	      
	      пакеты у которых порт назначения равен указанному  параметру.
	      	      
	example:
	    ./tmlog -i lo-ig-bin_full-1 -o textfullout -p t -f fb
	    ./tmlog -i lo-ig-bin-1 -o textbinout -p t -f b
	    ./tmlog -i lo-ig-bin_full-1 -o textfullout -p t -f fb --data '0|*|23-7/1,9|*|*|*|1,3'
	    ./tmlog -i lo-ig-bin-1 -o textbinout -p t -f b --ptype output
	    ./tmlog -i lo-ig-bin-1 -o textbinout -p t -f b --proto 1
	    ./tmlog -i lo-ig-bin-1 -o textbinout -p t -f b --proto 6 --dport 21
	    ./tmlog -i lo-ig-bin-1 -o textbinout -p t -f b --sport 80
	    
    5. cutdb
    
	Для данной утилиты параметры простые, 
	первый параметр это файл с базой от save_on_time, второй параметр
	и остальные это перечисления функций, сохраненные данные для 
	которых нужно удалить, проще говоря обнулить.
	
	example:
	    ./cutdb save_on_time-lo log_by_each_ip_local log_by_port_ip
    
	Удаляет информацию для функций log_by_each_ip_local и log_by_port_ip,
	из файла save_on_time-lo.
		
  13. Преимущества Traffic Accounting
    
    Преимущества Traffic Accounting
    заключаются в следующем:
    
    1. Assembler
      
      Traffic Accounting написан на языке
      низкого уровня Assembler, и очень хорошо
      и досконально оптимизирован по скорости.
      
    2. Режим сервера
    
      Traffic Accounting может быть запущен
      в режиме сервера, что позволяет считать
      траффик для удалённых машин.
      
    3. Многофункциональность
    
      Traffic Accounting имеет множество функций
      для работы с трафиком. Функций практически
      все проблемы с фильтрацией пакетов.
      Можно сразу подсчитывать траффик по портам и
      протоколам. Колличество операций над трафиком
      составляет 86.
      Имеются функции создания отчётов.
      
    4. Размер
      
      Traffic Accounting его исполняемый файл имеет
      очень маленький размер, приблизительно 70 кб.
      Такой размер идеально подходит для мини дистрибутивов,
      так как кроме исполняемого файла больше ничего не нужно.
      И Traffic Accounting не использует никаких библиотек,
      требуется только ядро Linux.
            